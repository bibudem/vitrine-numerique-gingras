{"version":3,"file":"LibraryScene-CwQ7uYtg.js","sources":["../../src/vue/node_modules/lodash/_baseClamp.js","../../src/vue/node_modules/lodash/clamp.js","../../src/vue/src/pages/Home/blocks/webgl/assets.ts","../../src/vue/src/pages/Home/blocks/webgl/items.ts","../../src/vue/src/pages/Home/blocks/webgl/LibraryScene.ts"],"sourcesContent":["/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n","var baseClamp = require('./_baseClamp'),\n    toNumber = require('./toNumber');\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n","const textures = [\n  {\n    id: \"foreground\",\n    width: 2090,\n    height: 906,\n    scale: 1.42,\n  },\n  {\n    id: \"sideLeft\",\n    width: 1098,\n    height: 1956,\n    scale: 1.55,\n  },\n  {\n    id: \"sideRight\",\n    width: 1098,\n    height: 1956,\n    scale: 1.55,\n  },\n  {\n    id: \"background\",\n    width: 1783,\n    height: 1431,\n    scale: 1.73,\n  }\n];\n\nexport { textures };\n\n","const textures = [\n  {\n    id: \"box\",\n    width: 794,\n    height: 503,\n    scale: 1.35,\n  },\n  {\n    id: \"record\",\n    width: 835,\n    height: 430,\n    scale: 1.4,\n  },\n  {\n    id: \"partitions\",\n    width: 670,\n    height: 360,\n    scale: 1,\n  },\n  {\n    id: \"typewriter\",\n    width: 790,\n    height: 524,\n    scale: 1.45,\n  },\n  {\n    id: \"poster\",\n    width: 353,\n    height: 407,\n    scale: 0.9,\n  },\n  {\n    id: \"carnet\",\n    width: 292,\n    height: 430,\n    scale: 0.8,\n  },\n  {\n    id: \"livre\",\n    width: 279,\n    height: 459,\n    scale: 1.1,\n  },\n  {\n    id: \"violon\",\n    width: 312,\n    height: 644,\n    scale: 1.8,\n  },\n\n];\n\nexport { textures };\n\n","import { store as appStore } from 'plugins/store/app';\nimport { store as interfaceStore } from 'store/interface';\n\nimport { WebGLRenderParams, WebGLSceneOptions } from \"components/WebGL/gl\";\nimport { WebGLScene } from 'components/WebGL/three/glScene';\nimport { store as loaderStore } from 'components/ui/Loader/store';\nimport { gsap } from \"gsap\"; // Import GSAP at the top\nimport { clamp, each, find } from \"lodash\";\nimport { damp3 } from \"maath/easing\";\nimport emitter, { EVENTS } from \"plugins/store/events\";\nimport { mainWebGLRenderer } from \"plugins/webgl/three\";\nimport { Group, Mesh, MeshBasicMaterial, Object3D, Object3DEventMap, PlaneGeometry, Raycaster, ShaderMaterial, Vector2 } from \"three\";\nimport { textures } from \"./assets\";\nimport { textures as texturesItem } from './items'; // Assuming textures are exported from item.ts\n\nconst commonGeometry = new PlaneGeometry(1, 1);\nconst commonMaterial = new MeshBasicMaterial({ transparent: true });\n\nexport default class extends WebGLScene {\n  private raycaster: Raycaster = new Raycaster();\n  isUserActive = false;\n  userActivityTimeout: ReturnType<typeof setTimeout> | null = null;\n  resetTimeout: ReturnType<typeof setTimeout> | null = null;\n  sceneIndex: number;\n  handlers: Obj;\n  mouse: Point = { x: 0, y: 0 };\n  touchActive = false;\n  disableClick = false;\n  mouseOffset: Point = { x: 20, y: 15 };\n  name: string = \"LibraryScene\";\n  touchTimers = {\n    start: 0,\n    end: 0,\n    tap: false\n  }\n\n  constructor(options: WebGLSceneOptions) {\n    // new glScene(options)\n    super(options);\n    this.resetUserActivity()\n\n    this.handlers = {\n      click: this.handleClick.bind(this),\n      move: this.onMouseMove.bind(this),\n      start: this.handleTouchStart.bind(this),\n      end: this.onTouchEnd.bind(this),\n      tmove: this.onTouchMove.bind(this),\n    }\n    this.sceneIndex = 1;\n    return this;\n  }\n  // Event handler function\n  resetUserActivity() {\n    this.isUserActive = true;\n    if (this.userActivityTimeout) clearTimeout(this.userActivityTimeout);\n    if (this.resetTimeout) clearTimeout(this.resetTimeout);\n\n    this.userActivityTimeout = setTimeout(() => {\n      this.isUserActive = false;\n      this.resetTimeout = setTimeout(() => {\n        this.isUserActive = true;\n      }, 1000);\n    }, 30000);\n  }\n\n  build() {\n\n    const group = new Group();\n    group.name = \"mainGroup\";\n    group.position.z = 0;\n\n    const groupForeground = new Group();\n    groupForeground.name = \"foregroundGroup\";\n    // groupForeground.position.set(-0.2, -1.55, 0)\n    groupForeground.userData.position = groupForeground.position.clone();\n\n    const groupLeftSide = new Group();\n    groupLeftSide.name = \"leftSideGroup\";\n    // groupLeftSide.position.set((-this.sceneSize.width / 2) - 0.1, 0.1, 0)\n    groupLeftSide.userData.position = groupLeftSide.position.clone();\n\n    const groupRightSide = new Group();\n    groupRightSide.name = \"rightSideGroup\";\n    // groupRightSide.position.set((this.sceneSize.width / 2) + 0.55, 0.1, 0);\n    groupRightSide.userData.position = groupRightSide.position.clone();\n\n    const groupBackground = new Group();\n    groupBackground.name = \"backgroundGroup\";\n    // groupBackground.position.set(0, 0.5, 0)\n    groupBackground.userData.position = groupBackground.position.clone();\n\n    const groupObject = new Group();\n    groupObject.name = \"groupObject\";\n    groupObject.position.z = 0;\n    this.scene.add(group);\n    this.scene.add(groupObject);\n    this.scene.add(groupBackground);\n    this.scene.add(groupLeftSide);\n    this.scene.add(groupRightSide);\n    this.scene.add(groupForeground);\n\n    // Load all textures\n    const assets = ['background', 'sideLeft', 'sideRight', 'foreground'];\n    const mesh_positions = [\n      { x: 0, y: 0, z: -5, scx: 0., scy: 0.22 },\n      { x: -1, y: 0, z: -2, scx: 1.1, scy: 0.12 }, // Adjusted for sideLeft\n      { x: 1, y: 0, z: -2, scx: -1.2, scy: 0.12 }, // Adjusted for sideRight\n      { x: 0, y: -1, z: -1, scx: 0., scy: 1.22 },\n    ];\n\n    assets.forEach((id, index) => {\n      const texObj = find(textures, t => t.id === id);\n      if (texObj) {\n        const data = loaderStore.getTexture(texObj.id);\n\n        const material = commonMaterial.clone();\n        material.map = data;\n        material.opacity = 1;\n        material.toneMapped = false;\n\n        const mesh = new Mesh(commonGeometry, material);\n        mesh.userData.position_ref = mesh_positions[index];\n        mesh.name = texObj.id;\n        mesh.userData.scale = texObj.scale;\n        mesh.userData.isBase = true;\n        group.add(mesh);\n\n        //if assets is foreground, add to foreground group\n        if (id === \"foreground\") {\n          groupForeground.add(mesh);\n        }\n\n        if (id === \"sideLeft\") {\n          groupLeftSide.add(mesh);\n        }\n        if (id === \"sideRight\") {\n          groupRightSide.add(mesh);\n        }\n\n        if (id === \"background\") {\n          groupBackground.add(mesh);\n        }\n\n        //userData size\n        mesh.userData.size = {\n          format: texObj.width > texObj.height ? \"paysage\" : \"portrait\",\n          ratio: texObj.width > texObj.height ? texObj.height / texObj.width : texObj.width / texObj.height\n        };\n      }\n    });\n\n    // Load new objects \n    const newAssets = ['record', 'typewriter', 'partitions', 'carnet', 'poster', 'livre', 'violon', 'box']; // Add your new asset names here\n    const newMeshPositions = [\n      { x: -1.34, y: 0.05, z: -0.9999 },\n      { x: 2.6, y: 0.237, z: -0.9999 },    // 30% to the right\n      { x: 0.11, y: 0.068, z: -0.9999 },\n      { x: -0.29, y: -0.02, z: -1.9999 },\n      { x: 1.6, y: 1.02, z: -1.9999 },\n      { x: 0.016, y: 1.04, z: -1.9999 },\n      { x: 3.85, y: 1.35, z: -4.9999 },\n      { x: -2.02, y: -0.82, z: -0.9999 },\n    ];\n    const bgColors = [\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n    ]\n\n    //objects\n    newAssets.forEach((id, index) => {\n      const texObj = find(texturesItem, t => t.id === id);\n      if (texObj) {\n        // Load both main and glow textures\n        const mainTexture = loaderStore.getTexture(texObj.id);\n        const glowTexture = loaderStore.getTexture(`${texObj.id}_glow`);\n\n        // Create ShaderMaterial using both textures\n        const material = new ShaderMaterial({\n          uniforms: {\n            uTexture1: { value: mainTexture },\n            uTexture2: { value: glowTexture },\n            uHover: { value: 0.0 }, // Default hover value\n            uOpacity: { value: 0.0 }, // Default opacity\n          },\n          vertexShader: `\n            varying vec2 vUv;\n            void main() {\n              vUv = uv;\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n          `,\n          fragmentShader: `\n            uniform sampler2D uTexture1;\n            uniform sampler2D uTexture2;\n            uniform float uHover; // Uniform for hover effect\n            varying vec2 vUv;\n\n            void main() {\n              vec4 tex1 = texture2D(uTexture1, vUv);\n              vec4 tex2 = texture2D(uTexture2, vUv);\n              vec4 glow = vec4(tex2.rgb, tex2.a * uHover); // Apply hover value to the glow texture\n\n              // Apply gamma correction\n              vec4 correctedTex1 = pow(tex1, vec4(2.2));\n              vec4 correctedGlow = pow(glow, vec4(2.2));\n\n              gl_FragColor = correctedTex1 + correctedGlow; // Overlay the glow texture on top of the base texture\n              gl_FragColor = pow(gl_FragColor, vec4(1.0 / 2.2)); // Apply inverse gamma correction\n            }\n          `,\n          transparent: true, // Allow transparency if needed\n        });\n        // Create the mesh and assign material\n        const mesh = new Mesh(commonGeometry, material);\n        mesh.userData.position_ref = newMeshPositions[index];\n        mesh.name = texObj.id;\n        mesh.userData.bgColor = bgColors[index];\n        mesh.userData.scale = texObj.scale;\n\n        // Add the mesh to the appropriate group\n        if (id === \"box\" || id === \"record\" || id === \"partitions\" || id === \"typewriter\") {\n          groupForeground.add(mesh);\n        }\n        if (id === \"poster\" || id === \"carnet\") {\n          groupLeftSide.add(mesh);\n        }\n        if (id === \"livre\") {\n          groupRightSide.add(mesh);\n        }\n        if (id === \"violon\") {\n          groupBackground.add(mesh);\n        }\n        // Set userData size\n        mesh.userData.size = {\n          format: texObj.width > texObj.height ? \"paysage\" : \"portrait\",\n          ratio: texObj.width > texObj.height ? texObj.height / texObj.width : texObj.width / texObj.height,\n        };\n        // Animate appearance sequentially using GSAP\n        // Sequential animation with staggered delay\n        gsap.to(mesh.material.uniforms.uOpacity, { value: 0.0, duration: 1.0 });\n\n\n        this.resize();\n      }\n    });\n\n  }\n\n  addEvents() {\n    mainWebGLRenderer?.domElement.addEventListener(\"click\", this.handlers.click);\n    mainWebGLRenderer?.domElement.addEventListener(\"mousemove\", this.handlers.move);\n    mainWebGLRenderer?.domElement.addEventListener(\"touchstart\", this.handlers.start);\n    mainWebGLRenderer?.domElement.addEventListener(\"touchmove\", this.handlers.tmove);\n    mainWebGLRenderer?.domElement.addEventListener(\"touchend\", this.handlers.end);\n  }\n\n  removeEvents() {\n    mainWebGLRenderer?.domElement.removeEventListener(\"click\", this.handlers.click);\n    mainWebGLRenderer?.domElement.removeEventListener(\"mousemove\", this.handlers.move);\n    mainWebGLRenderer?.domElement.removeEventListener(\"touchstart\", this.handlers.start);\n    mainWebGLRenderer?.domElement.removeEventListener(\"touchmove\", this.handlers.tmove);\n    mainWebGLRenderer?.domElement.removeEventListener(\"touchend\", this.handlers.end);\n  }\n\n  resizeGroup(group: Group) {\n    each(group.children, (child) => {\n      const defaultScale = child.userData.isBase ? this.sceneSize.height * child.userData.scale : child.userData.scale;\n\n      // Adjust the scale based on the new width\n      if (child.userData.size.format === 'paysage') {\n        child.scale.set(defaultScale, defaultScale * child.userData.size.ratio, 1);\n      } else {\n        child.scale.set(defaultScale * child.userData.size.ratio, defaultScale, 1);\n      }\n\n      // Set the position based on child id\n      if (child.userData.isBase) {\n\n        let posX = (this.sceneSize.width * child.userData.position_ref.x) + (child.scale.x * child.userData.position_ref.scx);\n\n        if (child.name === \"sideRight\") {\n          posX = Math.max(5, posX);\n        }\n\n        if (child.name === \"sideLeft\") {\n          posX = Math.min(-5, posX);\n        }\n\n        child.position.set(\n          posX,\n          this.sceneSize.height * child.userData.position_ref.y + (child.scale.y * child.userData.position_ref.scy),\n          child.userData.position_ref.z\n        );\n      } else {\n        // Set the position based on position_ref for other objects\n        const position = child.userData.position_ref;\n        child.position.set(group.children[0].position.x + position.x, group.children[0].position.y + position.y, position.z);\n      }\n\n      child.userData.position = child.position.clone();\n    });\n  }\n\n  // Resize is called by default (by the plugin) when the scene is created\n  resize() {\n    super.resize();\n\n    // If no children in the scene, let's build it\n    if (!this.scene.children.length) {\n      this.build();\n      this.addEvents();\n    } else {\n      const sideLeftGroup = this.scene.getObjectByName(\"leftSideGroup\") as Group;\n      const sideRightGroup = this.scene.getObjectByName(\"rightSideGroup\") as Group;\n      const foregroundGroup = this.scene.getObjectByName(\"foregroundGroup\") as Group;\n      const groupBackground = this.scene.getObjectByName(\"backgroundGroup\") as Group;\n\n      const groups = [sideLeftGroup, sideRightGroup, foregroundGroup, groupBackground];\n      each(groups, (group) => {\n        this.resizeGroup(group);\n      });\n    }\n  }\n\n\n  render(params: WebGLRenderParams) {\n    super.render(params);\n\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\") as Group;\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\") as Group;\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\") as Group;\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\") as Group;\n\n    //update mouse offset if the scene is too small\n    const sceneRatio = this.sceneSize.width / this.sceneSize.height;\n\n    this.mouseOffset.x = sceneRatio < 16 / 10 ? 140 : 20;\n\n    const speed = 0.5;\n    const offsetX = !this.mouse.x ? 0 : this.mouse.x / (this.sceneSize.width / this.mouseOffset.x);\n    const maxYOffset = 0.2; // Adjust this value based on your preference\n\n\n    let offsetY = this.mouse.y / (this.sceneSize.height / this.mouseOffset.y);\n    offsetY = clamp(offsetY, -maxYOffset * 2, maxYOffset);\n\n    const needsToBlink = !this.isUserActive;\n\n\n    // intersection\n    let isIntersecting: boolean = false;\n\n    // Convert this.mouse from Point to Vector2\n    const mousePosition = new Vector2(this.mouse.x, this.mouse.y);\n\n    // Use Raycaster for hover detection\n    this.raycaster.setFromCamera(mousePosition, this.camera);\n\n    if (groupBackground && groupBackground.children.length > 0) {\n\n      // Calculate the new position for the foreground with the mouse offset\n      const foregroundOffsetX = -(offsetX * 0.01);\n      const foregroundOffsetY = -(offsetY * 0.3);\n\n      // Damp the foreground group as a group\n      if(!this.touchTimers.tap) {\n        damp3(groupBackground.position, [\n          groupBackground.userData.position.x + foregroundOffsetX,\n          groupBackground.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"violon\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = groupBackground.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink ? 1.0 : 0.0);\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          if(isIntersecting && (!interfaceStore.hasTouch || this.touchTimers.tap)) {\n            // Interpolate the hoverValue gradually\n            mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n            // Apply the updated hoverValue to the shader uniform\n            material.uniforms.uHover.value = mesh.userData.hoverValue;\n          }\n        }\n      });\n    }\n\n    if (groupForeground && groupForeground.children.length > 0) {\n\n      // Calculate the new position for the foreground with the mouse offset\n      const foregroundOffsetX = -(offsetX * 0.1);\n      const foregroundOffsetY = -offsetY;\n\n\n      // Damp the foreground group as a group\n      if(!this.touchTimers.tap) {\n        damp3(groupForeground.position, [\n          groupForeground.userData.position.x + foregroundOffsetX,\n          groupForeground.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"box\", \"record\", \"typewriter\", \"partitions\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = groupForeground.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n          \n          if(isIntersecting && (!interfaceStore.hasTouch || this.touchTimers.tap)) {\n            // Interpolate the hoverValue gradually\n            mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n            // Apply the updated hoverValue to the shader uniform\n            material.uniforms.uHover.value = mesh.userData.hoverValue;\n          }\n        }\n      });\n    }\n\n    if (leftSideGroup && leftSideGroup.children.length > 0) {\n\n      const foregroundOffsetX = -(offsetX * 0.05);\n      const foregroundOffsetY = -offsetY * 0.7\n\n      // Damp the foreground group as a group\n      if(!this.touchTimers.tap) {\n        damp3(leftSideGroup.position, [\n          leftSideGroup.userData.position.x + foregroundOffsetX,\n          leftSideGroup.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"poster\", \"carnet\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = leftSideGroup.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          if(isIntersecting && (!interfaceStore.hasTouch || this.touchTimers.tap)) {\n            // Interpolate the hoverValue gradually\n            mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n            // Apply the updated hoverValue to the shader uniform\n            material.uniforms.uHover.value = mesh.userData.hoverValue;\n          }\n        }\n      });\n    }\n\n    if (rightSideGroup && rightSideGroup.children.length > 0) {\n\n      const foregroundOffsetX = -(offsetX * 0.05);\n      const foregroundOffsetY = -offsetY * 0.7;\n\n      // Damp the foreground group as a group\n      if(!this.touchTimers.tap) {\n        damp3(rightSideGroup.position, [\n          rightSideGroup.userData.position.x + foregroundOffsetX,\n          rightSideGroup.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"livre\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = rightSideGroup.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          if(isIntersecting && (!interfaceStore.hasTouch || this.touchTimers.tap)) {\n            // Interpolate the hoverValue gradually\n            mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n            // Apply the updated hoverValue to the shader uniform\n            material.uniforms.uHover.value = mesh.userData.hoverValue;\n          }\n        }\n      });\n    }\n\n    document.body.style.cursor = isIntersecting ? \"pointer\" : \"default\";\n  }\n\n  dispose() {\n    // glScene.dispose()\n    // dispose every geometry and material for every Mesh children\n    super.dispose();\n\n    this.removeEvents();\n    document.body.style.cursor = \"default\";\n  }\n  // Get The Real Mouse Position with the offset position to the top left point\n  getMousePosition(evt: MouseEvent | TouchEvent) {\n    const el = evt.currentTarget as HTMLElement;\n    const bounds = el.getBoundingClientRect();\n\n    let x = 0,\n      y = 0;\n\n    if (evt instanceof MouseEvent) {\n      x = evt.clientX - bounds.left;\n      y = evt.clientY - bounds.top;\n    } else if (evt instanceof TouchEvent && evt.touches.length > 0) {\n      x = evt.touches[0].clientX - bounds.left;\n      y = evt.touches[0].clientY - bounds.top;\n    }\n\n    this.mouse.x = (x / mainWebGLRenderer!.domElement.offsetWidth) * 2 - 1;\n    this.mouse.y = -(y / mainWebGLRenderer!.domElement.offsetHeight) * 2 + 1;\n  }\n\n  onMouseMove(e: MouseEvent): void {\n    this.getMousePosition(e);\n    this.resetUserActivity();\n  }\n\n  // Handle touch start\n  handleTouchStart(e: TouchEvent) {\n    this.touchActive = true;\n\n    if (e.touches.length > 0) {\n      e.preventDefault();\n      this.getMousePosition(e);\n\n      // Trigger the raycasting and handle intersections\n      this.resetUserActivity();\n\n      this.touchTimers.start = Date.now();\n    }\n  }\n\n  onTouchEnd(): void {\n    this.touchActive = false;\n    this.touchTimers.end = Date.now();\n\n    //tap\n    const clickDelay = (this.touchTimers.end - this.touchTimers.start);\n    if(clickDelay < 250) { \n      this.touchTimers.tap = true;\n      this.handleIntersections();\n    }\n  }\n\n  onTouchMove(e : TouchEvent): void {\n    if (!this.touchActive) return;\n\n    this.getMousePosition(e);\n    this.resetUserActivity();\n  }\n\n  handleClick(e: MouseEvent) {\n    // Normalize mouse coordinates\n    this.getMousePosition(e);\n\n    // Trigger the raycasting and handle intersections\n    this.handleIntersections();\n    this.resetUserActivity();\n  }\n\n\n  handleIntersections() {\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n    const newAssets = ['record', 'typewriter', 'partitions', 'carnet', 'poster', 'livre', 'violon', 'box'];\n\n    if (this.disableClick) return;\n    let intersects;\n\n    // Get only the meshes in newAssets from the relevant groups\n    if (leftSideGroup && rightSideGroup && groupForeground && groupBackground) {\n      const meshesToCheck = [\n        ...newAssets.map((id) => {\n          const texObj = find(texturesItem, t => t.id === id);\n          let mesh = null;\n          if (texObj) {\n            mesh = leftSideGroup.getObjectByName(texObj.id)\n              || rightSideGroup.getObjectByName(texObj.id)\n              || groupBackground.getObjectByName(texObj.id)\n              || groupForeground.getObjectByName(texObj.id);\n          }\n          return mesh && mesh instanceof Mesh && mesh.material instanceof ShaderMaterial ? mesh : null;\n        })\n      ]\n        .filter((mesh): mesh is Mesh => mesh !== null); // This ensures that we only keep valid Mesh objects\n\n\n      if (meshesToCheck.length > 0) {\n        intersects = this.raycaster.intersectObjects(meshesToCheck);\n      }\n    }\n\n    if (intersects && intersects.length > 0) {\n      const clickedObject = intersects[0].object;\n\n      // Trigger fade-out effect and URL redirect\n      this.fadeOutAndRedirect(clickedObject);\n    }\n    else{\n      this.touchTimers.tap = false;\n    }\n  }\n\n  fadeOutAndRedirect(clickedObject: Object3D<Object3DEventMap>) {\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n\n    appStore.disableApp(true);\n    this.disableClick = true;\n\n    if (leftSideGroup && rightSideGroup && groupForeground && groupBackground) {\n      // Get all meshes from all groups for the fade effect\n      const allMeshes = [\n        ...leftSideGroup.children,\n        ...rightSideGroup.children,\n        ...groupForeground.children,\n        ...groupBackground.children\n      ]\n        .filter(child => child instanceof Mesh && child.material instanceof ShaderMaterial);  // Filter only ShaderMaterial meshes\n\n      // Fade out all meshes first, then the clicked one\n      gsap.timeline()\n        .to(\n          allMeshes.map((mesh) => {\n            // Ensure the object is a Mesh before accessing material\n            if (mesh instanceof Mesh && mesh.material instanceof ShaderMaterial) {\n              return mesh.material.uniforms.uOpacity;\n            }\n            return null; // Return null if it's not a ShaderMaterial\n          }).filter((uniform) => uniform !== null), // Filter out null values\n          {\n            value: 0, // Fade out all items\n            duration: 1,\n            stagger: 0.1, // Stagger the fade out effect for sequential disappearing\n            ease: \"power2.out\"\n          })\n        .to(\n          clickedObject instanceof Mesh && clickedObject.material instanceof ShaderMaterial\n            ? (clickedObject.material as ShaderMaterial).uniforms.uOpacity\n            : null,\n          {\n            value: 0, // Fade out the clicked object last\n            duration: 1,\n            ease: \"power2.out\"\n          }\n        )\n        .add(() => {\n          // After fade-out animation, navigate to the specific URL for clicked object\n          emitter.emit(EVENTS.CLICK_THEME, { name: clickedObject.name, bgColor: clickedObject.userData.bgColor });\n          //this.getUrlForClickedObject(clickedObject);\n          //window.location.href = url; // Redirect to the URL\n        }, 1);\n    }\n  }\n\n  exitFromMainHeader(url: string) {\n    let myMesh: O<Object3D<Object3DEventMap>> = undefined;\n\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n\n    switch (url) {\n      case \"/yannick-nezet-seguin/\":\n        myMesh = groupForeground?.getObjectByName(\"partitions\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/charles-dutoit/\":\n        myMesh = rightSideGroup?.getObjectByName(\"livre\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/universite-de-montreal/\":\n        myMesh = leftSideGroup?.getObjectByName(\"carnet\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/metier-role-de-critique/\":\n        myMesh = groupForeground?.getObjectByName(\"typewriter\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/les-raretes/\":\n        myMesh = groupForeground?.getObjectByName(\"box\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/festival-de-lanaudiere/\":\n        myMesh = groupBackground?.getObjectByName(\"violon\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/oeuvres-preferees/\":\n        myMesh = groupForeground?.getObjectByName(\"record\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/maria-callas/\":\n        myMesh = leftSideGroup?.getObjectByName(\"poster\") as Object3D<Object3DEventMap>;\n        break;\n    }\n\n    if (myMesh) {\n      this.fadeOutAndRedirect(myMesh);\n    }\n  }\n\n\n\n\n\n\n\n\n}\n\n"],"names":["baseClamp","number","lower","upper","_baseClamp","require$$0","toNumber","require$$1","clamp","clamp_1","textures","commonGeometry","PlaneGeometry","commonMaterial","MeshBasicMaterial","LibraryScene","WebGLScene","options","__publicField","Raycaster","group","Group","groupForeground","groupLeftSide","groupRightSide","groupBackground","groupObject","assets","mesh_positions","id","index","texObj","find","t","data","loaderStore","material","mesh","Mesh","newAssets","newMeshPositions","bgColors","texturesItem","mainTexture","glowTexture","ShaderMaterial","gsap","mainWebGLRenderer","each","child","defaultScale","posX","position","sideLeftGroup","sideRightGroup","foregroundGroup","params","rightSideGroup","sceneRatio","speed","offsetX","maxYOffset","offsetY","isIntersecting","mousePosition","Vector2","foregroundOffsetX","damp3","foregroundOffsetY","name","intersects","targetValue","needsToBlink","interfaceStore","leftSideGroup"],"mappings":"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","x_google_ignoreList":[0,1]}
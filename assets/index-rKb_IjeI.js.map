{"version":3,"mappings":"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","names":["require$$0","require$$1","isIterateeCall","require$$2","require$$3","object","sources","index","length","guard","source","props","propsIndex","propsLength","key","value","noop","setToArray","INFINITY","createSet","values","require$$4","require$$5","baseUniq","array","iteratee","comparator","includes","isCommon","result","seen","set","outer","computed","seenIndex","appended","dynamicMasked","number","mask","re","date","day","month","year","str","dayMonthYeah","other","prop","model","CountryValue","target","passwordValue","isEqual","validationRules","rules","required","rulesFunctions","map","rule","defaultRule","baseFlatten","concat","args","collection","start","end","default_value","count","i","obj","arrays","a","b","val","normalize","split","_collapse","words","filter","is_stemmer","keys","final","removal","tmp","regexp","len","string","prev","char","filtered","word","prototype","register","self","arg","callback","promise","resolve","res","limit","offset","suggest","check","check_suggest","size","x","word_arr","word_arr_len","check_new","found","y","arr","arr_len","z","check_idx","id","mandatory","union","query","options","cache","pos","item","preset","field","index_doc","data","on_done","return_value","idx","_register","charset","lang","resolution","optimize","context","default_encoder","Cache","content","_append","_skip_update","dupes_ctx","dupes","depth","term","term_length","score","token","partial_score","dupes_inner","keyword","context_score","swap","append","query_new","single_term","bidirectional","_skip_deletion","refs","task","factory","encode","message","opt","is_node_js","_self","msg","document","store","marker","tree","tag","_resolve","result_field","pluck","enrich","bool","promises","field_options","state","init","Module","ApiHelper","createSearchIndex","searchIndex","FlexSearchDocument","entry","setDefaultFilters","routeQuery","search","syncRouterQuery","clear","arrComputed","uniqBy","flatMap","flatMapDeep","paginated","autocomplete","i18nLocale","i18nStore","SearchStore","route","router","useRouter","suggestionElem","ready","submit","suggestion","searchSuggestion","nextPage","_component_ui_button","_resolveComponent","_ctx","_openBlock","_createElementBlock","full","_toDisplayString","_createBlock","_component_KoddeinForm","_cache","status","_withCtx","_createVNode","_component_KoddeinField","_mergeProps","$event","_createCommentVNode","_createElementVNode","_Fragment","_renderList","_TransitionGroup","pagination"],"ignoreList":[0,1,2,3,4,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28],"sources":["../../src/vue/node_modules/lodash/defaults.js","../../src/vue/node_modules/lodash/noop.js","../../src/vue/node_modules/lodash/_createSet.js","../../src/vue/node_modules/lodash/_baseUniq.js","../../src/vue/node_modules/lodash/uniq.js","../../src/vue/src/components/UiKit/KoddeinVueForm/utils/masks.ts","../../src/vue/node_modules/lodash/isEqual.js","../../src/vue/src/components/UiKit/KoddeinVueForm/utils/validation-rules.ts","../../src/vue/src/components/UiKit/KoddeinVueForm/utils/index.ts","../../src/vue/src/components/UiKit/KoddeinVueForm/index.ts","../../src/vue/src/components/UiKit/Search/assets/icon.svg?raw","../../src/vue/node_modules/lodash/concat.js","../../src/vue/node_modules/lodash/flatMap.js","../../src/vue/node_modules/lodash/flatMapDeep.js","../../src/vue/node_modules/lodash/slice.js","../../src/vue/node_modules/lodash/uniqBy.js","../../src/vue/node_modules/flexsearch/dist/module/common.js","../../src/vue/node_modules/flexsearch/dist/module/lang.js","../../src/vue/node_modules/flexsearch/dist/module/lang/latin/default.js","../../src/vue/node_modules/flexsearch/dist/module/global.js","../../src/vue/node_modules/flexsearch/dist/module/async.js","../../src/vue/node_modules/flexsearch/dist/module/intersect.js","../../src/vue/node_modules/flexsearch/dist/module/cache.js","../../src/vue/node_modules/flexsearch/dist/module/preset.js","../../src/vue/node_modules/flexsearch/dist/module/serialize.js","../../src/vue/node_modules/flexsearch/dist/module/index.js","../../src/vue/node_modules/flexsearch/dist/module/worker/handler.js","../../src/vue/node_modules/flexsearch/dist/module/worker/index.js","../../src/vue/node_modules/flexsearch/dist/module/document.js","../../src/vue/src/components/UiKit/Search/store.ts","../../src/vue/src/components/UiKit/Search/index.vue"],"sourcesContent":["var baseRest = require('./_baseRest'),\n    eq = require('./eq'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keysIn = require('./keysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n","/**\n * Input Mask Models\n * > use with imask.js\n */\nimport { find } from 'lodash';\n\nconst masks:FormMaskMap = {\n  zipCode: {\n    mask: [\n      {\n        mask: 'a0a-0a0',\n        country: 'ca',\n      },\n      {\n        mask: '00000-0000',\n        country: 'usa',\n      },\n    ],\n    lazy: true,\n  },\n  phone: {\n    mask: '(000) 000-0000',\n    maxLength: 10,\n    autofix: true,\n    lazy: true,\n  },\n  creditCard: {\n    mask: '0000 000000 00000',\n    regex: '^3[47]\\\\d{0,13}',\n    brand: 'americanexpress',\n    lazy: true,\n  },\n  cvc: {\n    mask: '000',\n    lazy: true,\n  },\n  /** this one auto detect witch card it is\n   * then dispatch a `change:card-type` event within the cardType value\n   */\n  creditCards: {\n     \n    dispatch(appended:string, dynamicMasked:any): any {\n      const number = (dynamicMasked.value + appended).replace(/\\D/g, '');\n      // find current mask that match best\n      return find(dynamicMasked.compiledMasks, (mask /* key */) => {\n        const re = new RegExp(mask.regex);\n        return number.match(re);\n      });\n    },\n    mask: [\n      // list regex : https://stackoverflow.com/questions/9315647/regex-credit-card-number-tests#answer-23231321\n      {\n        mask: '0000 000000 00000',\n        regex: '^3[47]\\\\d{0,13}',\n        brand: 'americanexpress',\n      },\n      {\n        mask: '0000 0000 0000 0000',\n        regex: '^(5[1-5]\\\\d{0,2}|22[2-9]\\\\d{0,1}|2[3-7]\\\\d{0,2})\\\\d{0,12}',\n        brand: 'mastercard',\n      },\n      {\n        mask: '0000 0000 0000 0000',\n        regex: '^4\\\\d{0,15}',\n        brand: 'visa',\n      },\n      {\n        mask: '0000 0000 0000 0000',\n        brand: null,\n      },\n    ],\n    lazy: true,\n  },\n  date: {\n    mask: Date,\n    // pattern: 'Y-m-d',\n    pattern: 'd-m-Y',\n    lazy: true,\n    // define date -> str convertion\n    format(date:Date): string {\n      let day:any = date.getDate();\n      let month:any = date.getMonth() + 1;\n      const year = date.getFullYear();\n\n      if (day < 10) day = `0${ day}`;\n      if (month < 10) month = `0${ month}`;\n      return [day, month, year].join('-');\n    },\n    // define str -> date convertion\n    parse(str:string): Date {\n      const dayMonthYeah = str.split('-');\n      // example new Date(year, month, day);\n      // if pattern changed, change this.\n\n      return new Date(parseInt(dayMonthYeah[2], 10) , parseInt(dayMonthYeah[1], 10) - 1, parseInt(dayMonthYeah[0], 10));\n    },\n  },\n};\nexport default masks;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","/**\n * Validation rules\n * > because we always use the sames\n */\n\nimport { isArray, isEqual } from 'lodash';\n\nconst rules:FormRuleMap = {\n  /**\n   * make it required\n   */\n  REQUIRED(value: any) {\n    if (isArray(value) && !value.length) return 'required';\n    if ((value || value === 0) && value !== '') return true;\n    return 'required';\n  },\n  /**\n   * Simple email format validation\n   */\n  EMAIL_FORMAT(value: string) {\n    if (!value) return true;\n    const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i; // eslint-disable-line\n    if (emailRegex.test(value)) {\n      return true;\n    }\n    return 'email_format';\n  },\n  /**\n   * Simple phone format validation\n   */\n  PHONE_FORMAT(value: number) {\n    if (!value && value !== 0) return true;\n    const phoneRegex = /^(\\+\\d{1,2}\\s)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}$/i;  \n    if (phoneRegex.test(value.toString())) {\n      return true;\n    }\n    return 'phone_format';\n  },\n  /**\n   * Simple postal format validation depending of our current state value\n   * - add 'target' prop to model entry to make it work, will check our model for the country value value\n   */\n  POSTAL_FORMAT(value:string, prop:any, model:any) {\n    if (!value) return true;\n\n    const target = model[prop.target];\n    const CountryValue = target?.value;\n\n    if (CountryValue) {\n      switch (CountryValue) {\n        case 38:\n          return rules.CA_POSTAL_FORMAT(value);\n        default:\n          return rules.USA_POSTAL_FORMAT(value);\n      }\n    }\n\n    return rules.BOTH_POSTAL_FORMAT(value);\n  },\n  /**\n   * Simple postal format validation for Canada\n   */\n  CA_POSTAL_FORMAT(value:string) {\n    if (!value) return true;\n    const postalRegex = /^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ -]?\\d[ABCEGHJ-NPRSTV-Z]\\d$/i;  \n\n    if (postalRegex.test(value)) {\n      return true;\n    }\n    return 'ca_postal_format';\n  },\n   /**\n   * Simple postal format validation for USA\n   */\n  USA_POSTAL_FORMAT(value:string) {\n    if (!value) return true;\n    const usaRegex = /^(\\d{5}(-\\d{4})?)$/g;  \n    if (usaRegex.test(value)) {\n      return true;\n    }\n    return 'usa_postal_format';\n  },\n  /**\n   * Simple postal format validation for both Canada and USA\n   */\n  BOTH_POSTAL_FORMAT(value:string) {\n    if (!value) return true;\n\n    const usaRegex = /^(\\d{5}(-\\d{4})?)$/g;  \n    if (usaRegex.test(value)) {\n      return true;\n    }\n\n    const caRegex = /^[ABCEGHJ-NPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ -]?\\d[ABCEGHJ-NPRSTV-Z]\\d$/i;  \n    if (caRegex.test(value)) {\n      return true;\n    }\n    return 'both_postal_format';\n  },\n  /**\n   * Simple url format validation\n   */\n  URL_FORMAT(value:string) {\n    if (!value) return true;\n    const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([\\-\\.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?$/i; // eslint-disable-line\n    if (urlRegex.test(value)) {\n      return true;\n    }\n    return 'url_format';\n  },\n  /**\n   * Simple max length, handle number/string/array validation\n   * - add 'max' prop to model entry to make it work\n   */\n  MAX(value: any, prop:any) {\n    if (value && typeof (value) === 'number' && value <= prop.max && prop.type !== 'number') return true;\n    if (prop.type === 'number' && parseInt(value, 10) <= prop.max) return true;\n    if (value && typeof (value) !== 'number' && value.length <= prop.max && prop.type !== 'number') return true;\n    if (!value) return true;\n    return {\n      label: 'max',\n      attr: {\n        max: prop.max,\n      },\n    };\n  },\n  /**\n   * Simple min length, handle number/string/array validation\n   * - add 'min' prop to model entry to make it work\n   */\n  MIN(value: any, prop:any) {\n    if (value && typeof (value) === 'number' && value >= prop.min && prop.type !== 'number') return true;\n    if (prop.type === 'number' && parseInt(value, 10) >= prop.min) return true;\n    if (value && typeof (value) !== 'number' && value.length >= prop.min && prop.type !== 'number') return true;\n    if (!value) return true;\n    return {\n      label: 'min',\n      attr: {\n        min: prop.min,\n      },\n    };\n  },\n  /**\n   * Check if password model value is equal to confirmPassword model value\n   * - add 'target' prop to model entry, it will loook for that key in our model to compare - by defualt will look for password :mind_blown:\n   */\n  PASSWORD_IS_SAME(value:string, prop:any, model: any) {\n    if (!value && !prop.target) return true;\n    \n    const target = model[prop.target];\n    const passwordValue = target?.value;\n    \n    if (!passwordValue) return true;\n\n    if (passwordValue && isEqual(value, passwordValue)) return true;\n    return 'password_dont_matches';\n  },\n  /**\n   * Password must be at least 6 chars\n   */\n  PASSWORD_WEAK(value: string) {\n    const minLength = 6;\n    if (!value) return true;\n\n    return (value.length >= minLength) || {\n      label: 'password_weak',\n      attr: {\n        num: minLength,\n      },\n    };\n  },\n  /**\n   * Simple regex test, with prop regex\n   * - add 'regex' prop to model entry to make it work, will test with that regex\n   * - add 'message' prop to model entry to pass an error message if not valid\n   */\n  REGEX(value: any, prop:any) {\n    const regex = new RegExp(prop.regex, 'i');\n    if (value && prop.regex && regex.test(value)) return true;\n    if (!value) return true;\n    if (!regex) return true;\n    if (prop.message) return prop.message;\n    return 'generic';\n  },\n};\n\nexport default rules;\n","// @TODO replug with working i18n system, not present for now\n// @TODO typing for model ? - object with object keys with some required param + optional param + freeforall 'fieldProps'\n\nimport { defaults, Dictionary, each, has, keys, map, merge, uniq, zipObject } from 'lodash';\n// import i18n from 'plugins/i18n';\nimport i18n from 'plugins/i18n';\nimport masks from './masks';\nimport validationRules from './validation-rules';\n\n// Type definitions\nexport interface FormStatusMap {\n  PRISTINE: string;\n  DEFAULT: string;\n  SENDING: string;\n  SUCCESS: string;\n  ERROR: string;\n  INVALID: string;\n}\n\ntype FormRule = keyof typeof FORM_RULES;\n\n// Define the validation function type\ntype ValidationFunction = (value: any) => boolean | string;\n\ninterface FormFieldProps {\n  label?: string;\n  placeholder?: string;\n  default?: any;\n  type?: string;\n  errors?: string[];\n  value?: any;\n  validations?: Array<string | ValidationFunction>;\n  required?: boolean;\n  name?: string;\n  [key: string]: any; // For additional field properties\n}\n\ninterface FormModel {\n  [key: string]: FormFieldProps;\n}\n\n// Your existing code with types\nexport const FORM_STATUS: FormStatusMap = {\n  PRISTINE: 'PRISTINE',\n  DEFAULT: 'DEFAULT',\n  SENDING: 'SENDING',\n  SUCCESS: 'SUCCESS',\n  ERROR: 'ERROR',\n  INVALID: 'INVALID',\n};\n\nexport const MASK_MODELS = masks;\nexport const FORM_RULES = validationRules;\n\nexport function createValidationRules(rules: Array<string> = [], required = false): ValidationFunction[] {\n  if (required === true) {\n    rules.push('REQUIRED');\n  }\n\n  const rulesFunctions = map(rules, (rule) => {\n    const defaultRule = () => true;\n\n    if (typeof rule === 'string') {\n      if (!FORM_RULES[rule.toUpperCase() as FormRule]) {\n        console.warn(`form validation rule named \"${rule}\" is unknown`);\n        return defaultRule;\n      }\n      return FORM_RULES[rule.toUpperCase() as FormRule];\n    }\n    if (typeof rule === 'function') {\n      return rule;\n    }\n    console.warn('form validation rule unknown :', rule);\n    return defaultRule;\n  });\n\n  return uniq(rulesFunctions);\n}\n\nexport function createFormModel(model: FormModel, debug?: FormModel): FormModel {\n  each(model, (prop: FormFieldProps, name: string) => {\n    each(prop, (current, key) => {\n      if (key === 'label' || key === 'placeholder') {\n        if (typeof current === 'string' && current.indexOf('@:') === 0) {\n          prop[key] = i18n.global.t(current.replace('@:', ''));\n        }\n      }\n    });\n\n    defaults(prop, {\n      default: null,\n      type: 'text',\n      errors: [],\n    });\n\n    if (debug?.[name]) {\n      merge(prop, debug[name]);\n    }\n\n    if (!has(prop, 'value') && has(prop, 'default')) {\n      prop.value = prop.default;\n    }\n    prop.validations = createValidationRules(prop.validations as string[], prop.required);\n    if (!prop.name) {\n      prop.name = name;\n    }\n  });\n  return model;\n}\n\nexport function modelToKeyValue(model: FormModel): Dictionary<any> {\n  return zipObject(keys(model), map(model, ({ value }) => value));\n}\n","/**\n * our module entry point\n */\nimport { each } from 'lodash';\nimport { App, defineAsyncComponent } from 'vue';\nimport {\n  FORM_RULES, FORM_STATUS,\n  createFormModel,\n  createValidationRules,\n  modelToKeyValue,\n} from './utils';\n\nconst KoddeinBuilder  = defineAsyncComponent(()=>import('./Builder.vue'));\nconst KoddeinForm     = defineAsyncComponent(()=>import('./Form.vue'));\nconst KoddeinStep     = defineAsyncComponent(()=>import('./Step.vue'));\nconst KoddeinRow      = defineAsyncComponent(()=>import('./Row.vue'));\nconst KoddeinTitle    = defineAsyncComponent(()=>import('./Title.vue'));\nconst KoddeinField    = defineAsyncComponent(()=>import('./Field/index.vue'));\nconst KoddeinSubmit   = defineAsyncComponent(()=>import('./Submit.vue'));\nconst KoddeinButton   = defineAsyncComponent(()=>import('./SubmitUiButton.vue'));\n\n\nconst components = { KoddeinBuilder, KoddeinForm, KoddeinStep, KoddeinRow, KoddeinTitle, KoddeinField, KoddeinSubmit, KoddeinButton }\n\nexport const install = function(app:App):void{\n  each(components, (component, name)=>{\n    app.component(name, component)\n  })\n}\n\nexport default install\n\nexport {\n  FORM_RULES,\n  FORM_STATUS,\n  createFormModel,\n  modelToKeyValue,\n  createValidationRules,\n  KoddeinBuilder,\n  KoddeinForm,\n  KoddeinStep,\n  KoddeinRow,\n  KoddeinTitle,\n  KoddeinField,\n  KoddeinSubmit,\n  KoddeinButton,\n};\n\n","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"19.86\\\" height=\\\"12.73\\\"><path d=\\\"M0 5.86h18L12.79.71 13.5 0l5.66 5.66.7.7-6.36 6.37-.71-.73L18 6.86H0z\\\" fill-rule=\\\"evenodd\\\"/></svg>\\n\"","var arrayPush = require('./_arrayPush'),\n    baseFlatten = require('./_baseFlatten'),\n    copyArray = require('./_copyArray'),\n    isArray = require('./isArray');\n\n/**\n * Creates a new array concatenating `array` with any additional arrays\n * and/or values.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to concatenate.\n * @param {...*} [values] The values to concatenate.\n * @returns {Array} Returns the new concatenated array.\n * @example\n *\n * var array = [1];\n * var other = _.concat(array, 2, [3], [[4]]);\n *\n * console.log(other);\n * // => [1, 2, 3, [4]]\n *\n * console.log(array);\n * // => [1]\n */\nfunction concat() {\n  var length = arguments.length;\n  if (!length) {\n    return [];\n  }\n  var args = Array(length - 1),\n      array = arguments[0],\n      index = length;\n\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n}\n\nmodule.exports = concat;\n","var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nmodule.exports = flatMap;\n","var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * This method is like `_.flatMap` except that it recursively flattens the\n * mapped results.\n *\n * @static\n * @memberOf _\n * @since 4.7.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [[[n, n]]];\n * }\n *\n * _.flatMapDeep([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMapDeep(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), INFINITY);\n}\n\nmodule.exports = flatMapDeep;\n","var baseSlice = require('./_baseSlice'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` from `start` up to, but not including, `end`.\n *\n * **Note:** This method is used instead of\n * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n * returned.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction slice(array, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n    start = 0;\n    end = length;\n  }\n  else {\n    start = start == null ? 0 : toInteger(start);\n    end = end === undefined ? length : toInteger(end);\n  }\n  return baseSlice(array, start, end);\n}\n\nmodule.exports = slice;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","export function parse_option(value, default_value) {\n\n    return \"undefined\" != typeof value ? value : default_value;\n}\n\n/**\r\n * @param {!number} count\r\n * @returns {Array<Object>}\r\n */\n\nexport function create_object_array(count) {\n\n    const array = Array(count);\n\n    for (let i = 0; i < count; i++) {\n\n        array[i] = create_object();\n    }\n\n    return array;\n}\n\nexport function create_arrays(count) {\n\n    const array = Array(count);\n\n    for (let i = 0; i < count; i++) {\n\n        array[i] = [];\n    }\n\n    return array;\n}\n\n/**\r\n * @param {!Object} obj\r\n * @returns {Array<string>}\r\n */\n\nexport function get_keys(obj) {\n\n    return Object.keys(obj);\n}\n\nexport function create_object() {\n\n    return Object.create(null);\n}\n\nexport function concat(arrays) {\n\n    return [].concat.apply([], arrays);\n}\n\nexport function sort_by_length_down(a, b) {\n\n    return b.length - a.length;\n}\n\nexport function is_array(val) {\n\n    return val.constructor === Array;\n}\n\nexport function is_string(val) {\n\n    return \"string\" == typeof val;\n}\n\nexport function is_object(val) {\n\n    return \"object\" == typeof val;\n}\n\nexport function is_function(val) {\n\n    return \"function\" == typeof val;\n}","import { IndexInterface } from \"./type.js\";\nimport { create_object, get_keys } from \"./common.js\";\n\n/**\r\n * @param {!string} str\r\n * @param {boolean|Array<string|RegExp>=} normalize\r\n * @param {boolean|string|RegExp=} split\r\n * @param {boolean=} _collapse\r\n * @returns {string|Array<string>}\r\n * @this IndexInterface\r\n */\n\nexport function pipeline(str, normalize, split, _collapse) {\n\n    if (str) {\n\n        if (normalize) {\n\n            str = replace(str, /** @type {Array<string|RegExp>} */normalize);\n        }\n\n        if (this.matcher) {\n\n            str = replace(str, this.matcher);\n        }\n\n        if (this.stemmer && 1 < str.length) {\n\n            str = replace(str, this.stemmer);\n        }\n\n        if (_collapse && 1 < str.length) {\n\n            str = collapse(str);\n        }\n\n        if (split || \"\" === split) {\n\n            const words = str.split( /** @type {string|RegExp} */split);\n\n            return this.filter ? filter(words, this.filter) : words;\n        }\n    }\n\n    return str;\n}\n\n// TODO improve normalize + remove non-delimited chars like in \"I'm\" + split on whitespace+\n\nexport const regex_whitespace = /[\\p{Z}\\p{S}\\p{P}\\p{C}]+/u;\n// https://github.com/nextapps-de/flexsearch/pull/414\n//export const regex_whitespace = /[\\s\\xA0\\u2000-\\u200B\\u2028\\u2029\\u3000\\ufeff!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~]/\nconst regex_normalize = /[\\u0300-\\u036f]/g;\n\nexport function normalize(str) {\n\n    if (str.normalize) {\n\n        str = str.normalize(\"NFD\").replace(regex_normalize, \"\");\n    }\n\n    return str;\n}\n\n/**\r\n * @param {!string} str\r\n * @param {boolean|Array<string|RegExp>=} normalize\r\n * @param {boolean|string|RegExp=} split\r\n * @param {boolean=} _collapse\r\n * @returns {string|Array<string>}\r\n */\n\n// FlexSearch.prototype.pipeline = function(str, normalize, split, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n//         }\n//\n//         if(str && this.matcher){\n//\n//             str = replace(str, this.matcher);\n//         }\n//\n//         if(this.stemmer && str.length > 1){\n//\n//             str = replace(str, this.stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split || (split === \"\")){\n//\n//                 const words = str.split(/** @type {string|RegExp} */ (split));\n//\n//                 return this.filter ? filter(words, this.filter) : words;\n//             }\n//         }\n//     }\n//\n//     return str;\n// };\n\n// export function pipeline(str, normalize, matcher, stemmer, split, _filter, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, normalize);\n//         }\n//\n//         if(matcher && str){\n//\n//             str = replace(str, matcher);\n//         }\n//\n//         if(stemmer && str.length > 1){\n//\n//             str = replace(str, stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split !== false){\n//\n//                 str = str.split(split);\n//\n//                 if(_filter){\n//\n//                     str = filter(str, _filter);\n//                 }\n//             }\n//         }\n//     }\n//\n//     return str;\n// }\n\n\n/**\r\n * @param {Array<string>} words\r\n * @returns {Object<string, string>}\r\n */\n\nexport function init_filter(words) {\n\n    const filter = create_object();\n\n    for (let i = 0, length = words.length; i < length; i++) {\n\n        filter[words[i]] = 1;\n    }\n\n    return filter;\n}\n\n/**\r\n * @param {!Object<string, string>} obj\r\n * @param {boolean} is_stemmer\r\n * @returns {Array}\r\n */\n\nexport function init_stemmer_or_matcher(obj, is_stemmer) {\n    const keys = get_keys(obj),\n          length = keys.length,\n          final = [];\n\n\n    let removal = \"\",\n        count = 0;\n\n    for (let i = 0, key, tmp; i < length; i++) {\n\n        key = keys[i];\n        tmp = obj[key];\n\n        if (tmp) {\n\n            final[count++] = regex(is_stemmer ? \"(?!\\\\b)\" + key + \"(\\\\b|_)\" : key);\n            final[count++] = tmp;\n        } else {\n\n            removal += (removal ? \"|\" : \"\") + key;\n        }\n    }\n\n    if (removal) {\n\n        final[count++] = regex(is_stemmer ? \"(?!\\\\b)(\" + removal + \")(\\\\b|_)\" : \"(\" + removal + \")\");\n        final[count] = \"\";\n    }\n\n    return final;\n}\n\n/**\r\n * @param {!string} str\r\n * @param {Array} regexp\r\n * @returns {string}\r\n */\n\nexport function replace(str, regexp) {\n\n    for (let i = 0, len = regexp.length; i < len; i += 2) {\n\n        str = str.replace(regexp[i], regexp[i + 1]);\n\n        if (!str) {\n\n            break;\n        }\n    }\n\n    return str;\n}\n\n/**\r\n * @param {!string} str\r\n * @returns {RegExp}\r\n */\n\nexport function regex(str) {\n\n    return new RegExp(str, \"g\");\n}\n\n/**\r\n * Regex: replace(/(?:(\\w)(?:\\1)*)/g, \"$1\")\r\n * @param {!string} string\r\n * @returns {string}\r\n */\n\nexport function collapse(string) {\n\n    let final = \"\",\n        prev = \"\";\n\n    for (let i = 0, len = string.length, char; i < len; i++) {\n\n        if ((char = string[i]) !== prev) {\n\n            final += prev = char;\n        }\n    }\n\n    return final;\n}\n\n// TODO using fast-swap\nexport function filter(words, map) {\n    const length = words.length,\n          filtered = [];\n\n\n    for (let i = 0, count = 0; i < length; i++) {\n\n        const word = words[i];\n\n        if (word && !map[word]) {\n\n            filtered[count++] = word;\n        }\n    }\n\n    return filtered;\n}\n\n// const chars = {a:1, e:1, i:1, o:1, u:1, y:1};\n//\n// function collapse_repeating_chars(string){\n//\n//     let collapsed_string = \"\",\n//         char_prev = \"\",\n//         char_next = \"\";\n//\n//     for(let i = 0; i < string.length; i++){\n//\n//         const char = string[i];\n//\n//         if(char !== char_prev){\n//\n//             if(i && (char === \"h\")){\n//\n//                 if((chars[char_prev] && chars[char_next]) || (char_prev === \" \")){\n//\n//                     collapsed_string += char;\n//                 }\n//             }\n//             else{\n//\n//                 collapsed_string += char;\n//             }\n//         }\n//\n//         char_next = (\n//\n//             (i === (string.length - 1)) ?\n//\n//                 \"\"\n//             :\n//                 string[i + 1]\n//         );\n//\n//         char_prev = char;\n//     }\n//\n//     return collapsed_string;\n// }","import { IndexInterface } from \"../../type.js\";\nimport { pipeline, normalize, regex_whitespace } from \"../../lang.js\";\n\nexport const rtl = /* normalize: */\n/* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */\n/* normalize: */\n/* collapse: */!1;\nexport const tokenize = \"\";\nexport default {\n    encode: encode,\n    rtl: !1,\n    tokenize: \"\"\n\n    /**\r\n     * @param {string|number} str\r\n     * @this IndexInterface\r\n     */\n\n};export function encode(str) {\n\n    return pipeline.call(this,\n    /* string: */(\"\" + str).toLowerCase(), !1, /* split: */regex_whitespace, !1);\n}","export const global_lang = {};\nexport const global_charset = {};\n\n/**\r\n * @param {!string} name\r\n * @param {Object} charset\r\n */\n\nexport function registerCharset(name, charset) {\n\n  global_charset[name] = charset;\n}\n\n/**\r\n * @param {!string} name\r\n * @param {Object} lang\r\n */\n\nexport function registerLanguage(name, lang) {\n\n  global_lang[name] = lang;\n}","import { IndexInterface, DocumentInterface } from \"./type.js\";\n//import { promise as Promise } from \"./polyfill.js\";\nimport { is_function, is_object, is_string } from \"./common.js\";\n\nexport default function (prototype) {\n\n    register(prototype, \"add\");\n    register(prototype, \"append\");\n    register(prototype, \"search\");\n    register(prototype, \"update\");\n    register(prototype, \"remove\");\n}\n\nfunction register(prototype, key) {\n\n    prototype[key + \"Async\"] = function () {\n\n        /** @type {IndexInterface|DocumentInterface} */\n        const self = this,\n              args = /*[].slice.call*/arguments,\n              arg = args[args.length - 1];\n\n        let callback;\n\n        if (is_function(arg)) {\n\n            callback = arg;\n            delete args[args.length - 1];\n        }\n\n        const promise = new Promise(function (resolve) {\n\n            setTimeout(function () {\n\n                self.async = !0;\n                const res = self[key].apply(self, args);\n                self.async = !1;\n                resolve(res);\n            });\n        });\n\n        if (callback) {\n\n            promise.then(callback);\n            return this;\n        } else {\n\n            return promise;\n        }\n    };\n}","import { create_object, concat } from \"./common.js\";\n\n/**\r\n * Implementation based on Array.includes() provides better performance,\r\n * but it needs at least one word in the query which is less frequent.\r\n * Also on large indexes it does not scale well performance-wise.\r\n * This strategy also lacks of suggestion capabilities (matching & sorting).\r\n *\r\n * @param arrays\r\n * @param limit\r\n * @param offset\r\n * @param {boolean|Array=} suggest\r\n * @returns {Array}\r\n */\n\n// export function intersect(arrays, limit, offset, suggest) {\n//\n//     const length = arrays.length;\n//     let result = [];\n//     let check;\n//\n//     // determine shortest array and collect results\n//     // from the sparse relevance arrays\n//\n//     let smallest_size;\n//     let smallest_arr;\n//     let smallest_index;\n//\n//     for(let x = 0; x < length; x++){\n//\n//         const arr = arrays[x];\n//         const len = arr.length;\n//\n//         let size = 0;\n//\n//         for(let y = 0, tmp; y < len; y++){\n//\n//             tmp = arr[y];\n//\n//             if(tmp){\n//\n//                 size += tmp.length;\n//             }\n//         }\n//\n//         if(!smallest_size || (size < smallest_size)){\n//\n//             smallest_size = size;\n//             smallest_arr = arr;\n//             smallest_index = x;\n//         }\n//     }\n//\n//     smallest_arr = smallest_arr.length === 1 ?\n//\n//         smallest_arr[0]\n//     :\n//         concat(smallest_arr);\n//\n//     if(suggest){\n//\n//         suggest = [smallest_arr];\n//         check = create_object();\n//     }\n//\n//     let size = 0;\n//     let steps = 0;\n//\n//     // process terms in reversed order often results in better performance.\n//     // the outer loop must be the words array, using the\n//     // smallest array here disables the \"fast fail\" optimization.\n//\n//     for(let x = length - 1; x >= 0; x--){\n//\n//         if(x !== smallest_index){\n//\n//             steps++;\n//\n//             const word_arr = arrays[x];\n//             const word_arr_len = word_arr.length;\n//             const new_arr = [];\n//\n//             let count = 0;\n//\n//             for(let z = 0, id; z < smallest_arr.length; z++){\n//\n//                 id = smallest_arr[z];\n//\n//                 let found;\n//\n//                 // process relevance in forward order (direction is\n//                 // important for adding IDs during the last round)\n//\n//                 for(let y = 0; y < word_arr_len; y++){\n//\n//                     const arr = word_arr[y];\n//\n//                     if(arr.length){\n//\n//                         found = arr.includes(id);\n//\n//                         if(found){\n//\n//                             // check if in last round\n//\n//                             if(steps === length - 1){\n//\n//                                 if(offset){\n//\n//                                     offset--;\n//                                 }\n//                                 else{\n//\n//                                     result[size++] = id;\n//\n//                                     if(size === limit){\n//\n//                                         // fast path \"end reached\"\n//\n//                                         return result;\n//                                     }\n//                                 }\n//\n//                                 if(suggest){\n//\n//                                     check[id] = 1;\n//                                 }\n//                             }\n//\n//                             break;\n//                         }\n//                     }\n//                 }\n//\n//                 if(found){\n//\n//                     new_arr[count++] = id;\n//                 }\n//             }\n//\n//             if(suggest){\n//\n//                 suggest[steps] = new_arr;\n//             }\n//             else if(!count){\n//\n//                 return [];\n//             }\n//\n//             smallest_arr = new_arr;\n//         }\n//     }\n//\n//     if(suggest){\n//\n//         // needs to iterate in reverse direction\n//\n//         for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n//\n//             arr = suggest[x];\n//             len = arr && arr.length;\n//\n//             if(len){\n//\n//                 for(let y = 0, id; y < len; y++){\n//\n//                     id = arr[y];\n//\n//                     if(!check[id]){\n//\n//                         check[id] = 1;\n//\n//                         if(offset){\n//\n//                             offset--;\n//                         }\n//                         else{\n//\n//                             result[size++] = id;\n//\n//                             if(size === limit){\n//\n//                                 // fast path \"end reached\"\n//\n//                                 return result;\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//\n//     return result;\n// }\n\n/**\r\n * Implementation based on Object[key] provides better suggestions\r\n * capabilities and has less performance scaling issues on large indexes.\r\n *\r\n * @param arrays\r\n * @param limit\r\n * @param offset\r\n * @param {boolean|Array=} suggest\r\n * @returns {Array}\r\n */\n\nexport function intersect(arrays, limit, offset, suggest) {\n\n    const length = arrays.length;\n    let result = [],\n        check,\n        check_suggest,\n        size = 0;\n\n\n    if (suggest) {\n\n        suggest = [];\n    }\n\n    // process terms in reversed order often has advantage for the fast path \"end reached\".\n    // also a reversed order prioritize the order of words from a query.\n\n    for (let x = length - 1; 0 <= x; x--) {\n        const word_arr = arrays[x],\n              word_arr_len = word_arr.length,\n              check_new = create_object();\n\n\n        let found = !check;\n\n        // process relevance in forward order (direction is\n        // important for adding IDs during the last round)\n\n        for (let y = 0; y < word_arr_len; y++) {\n            const arr = word_arr[y],\n                  arr_len = arr.length;\n\n\n            if (arr_len) {\n\n                // loop through IDs\n\n                for (let z = 0, check_idx, id; z < arr_len; z++) {\n\n                    id = arr[z];\n\n                    if (check) {\n\n                        if (check[id]) {\n\n                            // check if in last round\n\n                            if (!x) {\n\n                                if (offset) {\n\n                                    offset--;\n                                } else {\n\n                                    result[size++] = id;\n\n                                    if (size === limit) {\n\n                                        // fast path \"end reached\"\n\n                                        return result;\n                                    }\n                                }\n                            }\n\n                            if (x || suggest) {\n\n                                check_new[id] = 1;\n                            }\n\n                            found = /* append: */ /* skip update: */ /* skip_update: */!0;\n                        }\n\n                        if (suggest) {\n\n                            check_idx = (check_suggest[id] || 0) + 1;\n                            check_suggest[id] = check_idx;\n\n                            // do not adding IDs which are already included in the result (saves one loop)\n                            // the first intersection match has the check index 2, so shift by -2\n\n                            if (check_idx < length) {\n\n                                const tmp = suggest[check_idx - 2] || (suggest[check_idx - 2] = []);\n                                tmp[tmp.length] = id;\n                            }\n                        }\n                    } else {\n\n                        // pre-fill in first round\n\n                        check_new[id] = 1;\n                    }\n                }\n            }\n        }\n\n        if (suggest) {\n\n            // re-use the first pre-filled check for suggestions\n\n            check || (check_suggest = check_new);\n        } else if (!found) {\n\n            return [];\n        }\n\n        check = check_new;\n    }\n\n    if (suggest) {\n\n        // needs to iterate in reverse direction\n\n        for (let x = suggest.length - 1, arr, len; 0 <= x; x--) {\n\n            arr = suggest[x];\n            len = arr.length;\n\n            for (let y = 0, id; y < len; y++) {\n\n                id = arr[y];\n\n                if (!check[id]) {\n\n                    if (offset) {\n\n                        offset--;\n                    } else {\n\n                        result[size++] = id;\n\n                        if (size === limit) {\n\n                            // fast path \"end reached\"\n\n                            return result;\n                        }\n                    }\n\n                    check[id] = 1;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\r\n * @param mandatory\r\n * @param arrays\r\n * @returns {Array}\r\n */\n\nexport function intersect_union(mandatory, arrays) {\n    const check = create_object(),\n          union = create_object(),\n          result = [];\n\n\n    for (let x = 0; x < mandatory.length; x++) {\n\n        check[mandatory[x]] = 1;\n    }\n\n    for (let x = 0, arr; x < arrays.length; x++) {\n\n        arr = arrays[x];\n\n        for (let y = 0, id; y < arr.length; y++) {\n\n            id = arr[y];\n\n            if (check[id]) {\n\n                if (!union[id]) {\n\n                    union[id] = 1;\n                    result[result.length] = id;\n                }\n            }\n        }\n    }\n\n    return result;\n}","import { IndexInterface, DocumentInterface } from \"./type.js\";\nimport { create_object, is_object } from \"./common.js\";\n\n/**\r\n * @param {boolean|number=} limit\r\n * @constructor\r\n */\n\nfunction CacheClass(limit) {\n\n    /** @private */\n    this.limit = !0 !== limit && limit;\n\n    /** @private */\n    this.cache = create_object();\n\n    /** @private */\n    this.queue = [];\n\n    //this.clear();\n}\n\nexport default CacheClass;\n\n/**\r\n * @param {string|Object} query\r\n * @param {number|Object=} limit\r\n * @param {Object=} options\r\n * @this {IndexInterface}\r\n * @returns {Array<number|string>}\r\n */\n\nexport function searchCache(query, limit, options) {\n\n    if (is_object(query)) {\n\n        query = query.query;\n    }\n\n    let cache = this.cache.get(query);\n\n    if (!cache) {\n\n        cache = this.search(query, limit, options);\n        this.cache.set(query, cache);\n    }\n\n    return cache;\n}\n\n// CacheClass.prototype.clear = function(){\n//\n//     /** @private */\n//     this.cache = create_object();\n//\n//     /** @private */\n//     this.queue = [];\n// };\n\nCacheClass.prototype.set = function (key, value) {\n\n    if (!this.cache[key]) {\n\n        // it is just a shame that native function array.shift() performs so bad\n\n        // const length = this.queue.length;\n        //\n        // this.queue[length] = key;\n        //\n        // if(length === this.limit){\n        //\n        //     delete this.cache[this.queue.shift()];\n        // }\n\n        // the same bad performance\n\n        // this.queue.unshift(key);\n        //\n        // if(this.queue.length === this.limit){\n        //\n        //     this.queue.pop();\n        // }\n\n        // fast implementation variant\n\n        // let length = this.queue.length;\n        //\n        // if(length === this.limit){\n        //\n        //     length--;\n        //\n        //     delete this.cache[this.queue[0]];\n        //\n        //     for(let x = 0; x < length; x++){\n        //\n        //         this.queue[x] = this.queue[x + 1];\n        //     }\n        // }\n        //\n        // this.queue[length] = key;\n\n        // current fastest implementation variant\n        // theoretically that should not perform better compared to the example above\n\n        let length = this.queue.length;\n\n        if (length === this.limit) {\n\n            delete this.cache[this.queue[length - 1]];\n        } else {\n\n            length++;\n        }\n\n        for (let x = length - 1; 0 < x; x--) {\n\n            this.queue[x] = this.queue[x - 1];\n        }\n\n        this.queue[0] = key;\n    }\n\n    this.cache[key] = value;\n};\n\nCacheClass.prototype.get = function (key) {\n\n    const cache = this.cache[key];\n\n    if (this.limit && cache) {\n\n        // probably the indexOf() method performs faster when matched content is on front (left-to-right)\n        // using lastIndexOf() does not help, it performs almost slower\n\n        const pos = this.queue.indexOf(key);\n\n        // if(pos < this.queue.length - 1){\n        //\n        //     const tmp = this.queue[pos];\n        //     this.queue[pos] = this.queue[pos + 1];\n        //     this.queue[pos + 1] = tmp;\n        // }\n\n        if (pos) {\n\n            const tmp = this.queue[pos - 1];\n            this.queue[pos - 1] = this.queue[pos];\n            this.queue[pos] = tmp;\n        }\n    }\n\n    return cache;\n};\n\nCacheClass.prototype.del = function (id) {\n\n    for (let i = 0, item, key; i < this.queue.length; i++) {\n\n        key = this.queue[i];\n        item = this.cache[key];\n\n        if (item.includes(id)) {\n\n            this.queue.splice(i--, 1);\n            delete this.cache[key];\n        }\n    }\n};","\nimport { is_string } from \"./common.js\";\n\n/**\r\n * @enum {Object}\r\n * @const\r\n */\n\nconst preset = {\n\n    memory: {\n        charset: \"latin:extra\",\n        //tokenize: \"strict\",\n        resolution: 3,\n        //threshold: 0,\n        minlength: 4,\n        fastupdate: /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */\n        /* collapse: */\n        /* collapse: */!1\n    },\n\n    performance: {\n        //charset: \"latin\",\n        //tokenize: \"strict\",\n        resolution: 3,\n        minlength: 3,\n        //fastupdate: true,\n        optimize: !1, //fastupdate: true,\n        context: {\n            depth: 2, resolution: 1\n            //bidirectional: false\n        }\n    },\n\n    match: {\n        charset: \"latin:extra\",\n        tokenize: \"reverse\"\n        //resolution: 9,\n        //threshold: 0\n    },\n\n    score: {\n        charset: \"latin:advanced\",\n        //tokenize: \"strict\",\n        resolution: 20,\n        minlength: 3,\n        context: {\n            depth: 3,\n            resolution: 9\n            //bidirectional: true\n        }\n    },\n\n    default: {\n        // charset: \"latin:default\",\n        // tokenize: \"strict\",\n        // resolution: 3,\n        // threshold: 0,\n        // depth: 3\n    }\n\n    // \"fast\": {\n    //     //charset: \"latin\",\n    //     //tokenize: \"strict\",\n    //     threshold: 8,\n    //     resolution: 9,\n    //     depth: 1\n    // }\n};\n\nexport default function apply_preset(options) {\n\n    if (is_string(options)) {\n\n        options = preset[options];\n    } else {\n\n        const preset = options.preset;\n\n        if (preset) {\n\n            options = Object.assign({}, preset[preset], /** @type {Object} */options);\n        }\n    }\n\n    return options;\n}","// TODO return promises instead of inner await\n\nimport { IndexInterface, DocumentInterface } from \"./type.js\";\nimport { create_object, is_string } from \"./common.js\";\n\nfunction async(callback, self, field, key, index_doc, index, data, on_done) {\n\n    setTimeout(function () {\n\n        const res = callback(field ? field + \".\" + key : key, JSON.stringify(data));\n\n        // await isn't supported by ES5\n\n        if (res && res.then) {\n\n            res.then(function () {\n\n                self.export(callback, self, field, index_doc, index + 1, on_done);\n            });\n        } else {\n\n            self.export(callback, self, field, index_doc, index + 1, on_done);\n        }\n    });\n}\n\n/**\r\n * @this IndexInterface\r\n */\n\nexport function exportIndex(callback, self, field, index_doc, index, on_done) {\n\n    let return_value = /* append: */ /* skip update: */ /* skip_update: */ /* skip post-processing: */!0;\n    if ('undefined' == typeof on_done) {\n        return_value = new Promise(resolve => {\n            on_done = resolve;\n        });\n    }\n\n    let key, data;\n\n    switch (index || (index = 0)) {\n\n        case 0:\n\n            key = \"reg\";\n\n            // fastupdate isn't supported by export\n\n            if (this.fastupdate) {\n\n                data = create_object();\n\n                for (let key in this.register) {\n\n                    data[key] = 1;\n                }\n            } else {\n\n                data = this.register;\n            }\n\n            break;\n\n        case 1:\n\n            key = \"cfg\";\n            data = {\n                doc: 0,\n                opt: this.optimize ? 1 : 0\n            };\n\n            break;\n\n        case 2:\n\n            key = \"map\";\n            data = this.map;\n            break;\n\n        case 3:\n\n            key = \"ctx\";\n            data = this.ctx;\n            break;\n\n        default:\n\n            if ('undefined' == typeof field && on_done) {\n\n                on_done();\n            }\n\n            return;\n    }\n\n    async(callback, self || this, field, key, index_doc, index, data, on_done);\n\n    return return_value;\n}\n\n/**\r\n * @this IndexInterface\r\n */\n\nexport function importIndex(key, data) {\n\n    if (!data) {\n\n        return;\n    }\n\n    if (is_string(data)) {\n\n        data = JSON.parse(data);\n    }\n\n    switch (key) {\n\n        case \"cfg\":\n\n            this.optimize = !!data.opt;\n            break;\n\n        case \"reg\":\n\n            // fastupdate isn't supported by import\n\n            this.fastupdate = /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* collapse: */!1;\n            this.register = data;\n            break;\n\n        case \"map\":\n\n            this.map = data;\n            break;\n\n        case \"ctx\":\n\n            this.ctx = data;\n            break;\n    }\n}\n\n/**\r\n * @this DocumentInterface\r\n */\n\nexport function exportDocument(callback, self, field, index_doc, index, on_done) {\n\n    let return_value;\n    if ('undefined' == typeof on_done) {\n        return_value = new Promise(resolve => {\n            on_done = resolve;\n        });\n    }\n\n    index || (index = 0);\n    index_doc || (index_doc = 0);\n\n    if (index_doc < this.field.length) {\n        const field = this.field[index_doc],\n              idx = this.index[field];\n\n\n        self = this;\n\n        setTimeout(function () {\n\n            if (!idx.export(callback, self, index ? field /*.replace(\":\", \"-\")*/ : \"\", index_doc, index++, on_done)) {\n\n                index_doc++;\n                index = 1;\n\n                self.export(callback, self, field, index_doc, index, on_done);\n            }\n        });\n    } else {\n\n        let key, data;\n\n        switch (index) {\n\n            case 1:\n\n                key = \"tag\";\n                data = this.tagindex;\n                field = null;\n                break;\n\n            case 2:\n\n                key = \"store\";\n                data = this.store;\n                field = null;\n                break;\n\n            // case 3:\n            //\n            //     key = \"reg\";\n            //     data = this.register;\n            //     break;\n\n            default:\n\n                on_done();\n                return;\n        }\n\n        async(callback, this, field, key, index_doc, index, data, on_done);\n    }\n\n    return return_value;\n}\n\n/**\r\n * @this DocumentInterface\r\n */\n\nexport function importDocument(key, data) {\n\n    if (!data) {\n\n        return;\n    }\n\n    if (is_string(data)) {\n\n        data = JSON.parse(data);\n    }\n\n    switch (key) {\n\n        case \"tag\":\n\n            this.tagindex = data;\n            break;\n\n        case \"reg\":\n\n            // fastupdate isn't supported by import\n\n            this.fastupdate = !1;\n            this.register = data;\n\n            for (let i = 0, index; i < this.field.length; i++) {\n\n                index = this.index[this.field[i]];\n                index.register = data;\n                index.fastupdate = !1;\n            }\n\n            break;\n\n        case \"store\":\n\n            this.store = data;\n            break;\n\n        default:\n\n            key = key.split(\".\");\n            const field = key[0];\n            key = key[1];\n\n            if (field && key) {\n\n                this.index[field].import(key, data);\n            }\n    }\n}","/**!\r\n * FlexSearch.js\r\n * Author and Copyright: Thomas Wilkerling\r\n * Licence: Apache-2.0\r\n * Hosted by Nextapps GmbH\r\n * https://github.com/nextapps-de/flexsearch\r\n */\n\nimport { IndexInterface } from \"./type.js\";\nimport { encode as default_encoder } from \"./lang/latin/default.js\";\nimport { create_object, create_object_array, concat, sort_by_length_down, is_array, is_string, is_object, parse_option } from \"./common.js\";\nimport { pipeline, init_stemmer_or_matcher, init_filter } from \"./lang.js\";\nimport { global_lang, global_charset } from \"./global.js\";\nimport apply_async from \"./async.js\";\nimport { intersect } from \"./intersect.js\";\nimport Cache, { searchCache } from \"./cache.js\";\nimport apply_preset from \"./preset.js\";\nimport { exportIndex, importIndex } from \"./serialize.js\";\n\n/**\r\n * @constructor\r\n * @implements IndexInterface\r\n * @param {Object=} options\r\n * @param {Object=} _register\r\n * @return {Index}\r\n */\n\nfunction Index(options, _register) {\n\n    if (!(this instanceof Index)) {\n\n        return new Index(options);\n    }\n\n    let charset, lang, tmp;\n\n    if (options) {\n\n        options = apply_preset(options);\n\n\n        charset = options.charset;\n        lang = options.lang;\n\n        if (is_string(charset)) {\n\n            if (-1 === charset.indexOf(\":\")) {\n\n                charset += \":default\";\n            }\n\n            charset = global_charset[charset];\n        }\n\n        if (is_string(lang)) {\n\n            lang = global_lang[lang];\n        }\n    } else {\n\n        options = {};\n    }\n\n    let resolution,\n        optimize,\n        context = options.context || {};\n\n    this.encode = options.encode || charset && charset.encode || default_encoder;\n    this.register = _register || create_object();\n    this.resolution = resolution = options.resolution || 9;\n    this.tokenize = tmp = charset && charset.tokenize || options.tokenize || \"strict\";\n    this.depth = \"strict\" === tmp && context.depth;\n    this.bidirectional = parse_option(context.bidirectional, /* append: */ /* skip update: */ /* skip_update: */!0);\n    this.optimize = optimize = parse_option(options.optimize, !0);\n    this.fastupdate = parse_option(options.fastupdate, !0);\n    this.minlength = options.minlength || 1;\n    this.boost = options.boost;\n\n    // when not using the memory strategy the score array should not pre-allocated to its full length\n\n    this.map = optimize ? create_object_array(resolution) : create_object();\n    this.resolution_ctx = resolution = context.resolution || 1;\n    this.ctx = optimize ? create_object_array(resolution) : create_object();\n    this.rtl = charset && charset.rtl || options.rtl;\n    this.matcher = (tmp = options.matcher || lang && lang.matcher) && init_stemmer_or_matcher(tmp, !1);\n    this.stemmer = (tmp = options.stemmer || lang && lang.stemmer) && init_stemmer_or_matcher(tmp, !0);\n    this.filter = (tmp = options.filter || lang && lang.filter) && init_filter(tmp);\n\n    this.cache = (tmp = options.cache) && new Cache(tmp);\n}\n\nexport default Index;\n\n//Index.prototype.pipeline = pipeline;\n\n/**\r\n * @param {!number|string} id\r\n * @param {!string} content\r\n */\n\nIndex.prototype.append = function (id, content) {\n\n    return this.add(id, content, !0);\n};\n\n// TODO:\n// string + number as text\n// boolean, null, undefined as ?\n\n/**\r\n * @param {!number|string} id\r\n * @param {!string} content\r\n * @param {boolean=} _append\r\n * @param {boolean=} _skip_update\r\n */\n\nIndex.prototype.add = function (id, content, _append, _skip_update) {\n\n    if (content && (id || 0 === id)) {\n\n        if (!_skip_update && !_append && this.register[id]) {\n\n            return this.update(id, content);\n        }\n\n        content = this.encode(\"\" + content);\n        const length = content.length;\n\n        if (length) {\n\n            // check context dupes to skip all contextual redundancy along a document\n\n            const dupes_ctx = create_object(),\n                  dupes = create_object(),\n                  depth = this.depth,\n                  resolution = this.resolution;\n\n\n            for (let i = 0; i < length; i++) {\n                let term = content[this.rtl ? length - 1 - i : i],\n                    term_length = term.length;\n\n\n                // skip dupes will break the context chain\n\n                if (term && term_length >= this.minlength && (depth || !dupes[term])) {\n                    let score = get_score(resolution, length, i),\n                        token = \"\";\n\n\n                    switch (this.tokenize) {\n\n                        case \"full\":\n\n                            if (2 < term_length) {\n\n                                for (let x = 0; x < term_length; x++) {\n\n                                    for (let y = term_length; y > x; y--) {\n\n                                        if (y - x >= this.minlength) {\n\n                                            const partial_score = get_score(resolution, length, i, term_length, x);\n                                            token = term.substring(x, y);\n                                            this.push_index(dupes, token, partial_score, id, _append);\n                                        }\n                                    }\n                                }\n\n                                break;\n                            }\n\n                        // fallthrough to next case when term length < 3\n\n                        case \"reverse\":\n\n                            // skip last round (this token exist already in \"forward\")\n\n                            if (1 < term_length) {\n\n                                for (let x = term_length - 1; 0 < x; x--) {\n\n                                    token = term[x] + token;\n\n                                    if (token.length >= this.minlength) {\n\n                                        const partial_score = get_score(resolution, length, i, term_length, x);\n                                        this.push_index(dupes, token, partial_score, id, _append);\n                                    }\n                                }\n\n                                token = \"\";\n                            }\n\n                        // fallthrough to next case to apply forward also\n\n                        case \"forward\":\n\n                            if (1 < term_length) {\n\n                                for (let x = 0; x < term_length; x++) {\n\n                                    token += term[x];\n\n                                    if (token.length >= this.minlength) {\n\n                                        this.push_index(dupes, token, score, id, _append);\n                                    }\n                                }\n\n                                break;\n                            }\n\n                        // fallthrough to next case when token has a length of 1\n\n                        default:\n                            // case \"strict\":\n\n                            if (this.boost) {\n\n                                score = Math.min(0 | score / this.boost(content, term, i), resolution - 1);\n                            }\n\n                            this.push_index(dupes, term, score, id, _append);\n\n                            // context is just supported by tokenizer \"strict\"\n\n                            if (depth) {\n\n                                if (1 < length && i < length - 1) {\n\n                                    // check inner dupes to skip repeating words in the current context\n\n                                    const dupes_inner = create_object(),\n                                          resolution = this.resolution_ctx,\n                                          keyword = term,\n                                          size = Math.min(depth + 1, length - i);\n\n\n                                    dupes_inner[keyword] = 1;\n\n                                    for (let x = 1; x < size; x++) {\n\n                                        term = content[this.rtl ? length - 1 - i - x : i + x];\n\n                                        if (term && term.length >= this.minlength && !dupes_inner[term]) {\n\n                                            dupes_inner[term] = 1;\n\n                                            const context_score = get_score(resolution + (length / 2 > resolution ? 0 : 1), length, i, size - 1, x - 1),\n                                                  swap = this.bidirectional && term > keyword;\n\n                                            this.push_index(dupes_ctx, swap ? keyword : term, context_score, id, _append, swap ? term : keyword);\n                                        }\n                                    }\n                                }\n                            }\n                    }\n                }\n            }\n\n            this.fastupdate || (this.register[id] = 1);\n        }\n    }\n\n    return this;\n};\n\n/**\r\n * @param {number} resolution\r\n * @param {number} length\r\n * @param {number} i\r\n * @param {number=} term_length\r\n * @param {number=} x\r\n * @returns {number}\r\n */\n\nfunction get_score(resolution, length, i, term_length, x) {\n\n    // console.log(\"resolution\", resolution);\n    // console.log(\"length\", length);\n    // console.log(\"term_length\", term_length);\n    // console.log(\"i\", i);\n    // console.log(\"x\", x);\n    // console.log((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1);\n\n    // the first resolution slot is reserved for the best match,\n    // when a query matches the first word(s).\n\n    // also to stretch score to the whole range of resolution, the\n    // calculation is shift by one and cut the floating point.\n    // this needs the resolution \"1\" to be handled additionally.\n\n    // do not stretch the resolution more than the term length will\n    // improve performance and memory, also it improves scoring in\n    // most cases between a short document and a long document\n\n    return i && 1 < resolution ? length + (term_length || 0) <= resolution ? i + (x || 0) : 0 | (resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1 : 0;\n}\n\n/**\r\n * @private\r\n * @param dupes\r\n * @param value\r\n * @param score\r\n * @param id\r\n * @param {boolean=} append\r\n * @param {string=} keyword\r\n */\n\nIndex.prototype.push_index = function (dupes, value, score, id, append, keyword) {\n\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!dupes[value] || keyword && !dupes[value][keyword]) {\n\n        if (this.optimize) {\n\n            arr = arr[score];\n        }\n\n        if (keyword) {\n\n            dupes = dupes[value] || (dupes[value] = create_object());\n            dupes[keyword] = 1;\n\n            arr = arr[keyword] || (arr[keyword] = create_object());\n        } else {\n\n            dupes[value] = 1;\n        }\n\n        arr = arr[value] || (arr[value] = []);\n\n        if (!this.optimize) {\n\n            arr = arr[score] || (arr[score] = []);\n        }\n\n        if (!append || !arr.includes(id)) {\n\n            arr[arr.length] = id;\n\n            // add a reference to the register for fast updates\n\n            if (this.fastupdate) {\n\n                const tmp = this.register[id] || (this.register[id] = []);\n                tmp[tmp.length] = arr;\n            }\n        }\n    }\n};\n\n/**\r\n * @param {string|Object} query\r\n * @param {number|Object=} limit\r\n * @param {Object=} options\r\n * @returns {Array<number|string>}\r\n */\n\nIndex.prototype.search = function (query, limit, options) {\n\n    if (!options) {\n\n        if (!limit && is_object(query)) {\n\n            options = /** @type {Object} */query;\n            query = options.query;\n        } else if (is_object(limit)) {\n\n            options = /** @type {Object} */limit;\n        }\n    }\n\n    let result = [],\n        length,\n        context,\n        suggest,\n        offset = 0;\n\n\n    if (options) {\n\n        query = options.query || query;\n        limit = options.limit;\n        offset = options.offset || 0;\n        context = options.context;\n        suggest = options.suggest;\n    }\n\n    if (query) {\n\n        query = /** @type {Array} */this.encode(\"\" + query);\n        length = query.length;\n\n        // TODO: solve this in one single loop below\n\n        if (1 < length) {\n            const dupes = create_object(),\n                  query_new = [];\n\n\n            for (let i = 0, count = 0, term; i < length; i++) {\n\n                term = query[i];\n\n                if (term && term.length >= this.minlength && !dupes[term]) {\n\n                    // this fast path can just apply when not in memory-optimized mode\n\n                    if (!this.optimize && !suggest && !this.map[term]) {\n\n                        // fast path \"not found\"\n\n                        return result;\n                    } else {\n\n                        query_new[count++] = term;\n                        dupes[term] = 1;\n                    }\n                }\n            }\n\n            query = query_new;\n            length = query.length;\n        }\n    }\n\n    if (!length) {\n\n        return result;\n    }\n\n    limit || (limit = 100);\n\n    let depth = this.depth && 1 < length && !1 !== context,\n        index = 0,\n        keyword;\n\n\n    if (depth) {\n\n        keyword = query[0];\n        index = 1;\n    } else {\n\n        if (1 < length) {\n\n            query.sort(sort_by_length_down);\n        }\n    }\n\n    for (let arr, term; index < length; index++) {\n\n        term = query[index];\n\n        // console.log(keyword);\n        // console.log(term);\n        // console.log(\"\");\n\n        if (depth) {\n\n            arr = this.add_result(result, suggest, limit, offset, 2 === length, term, keyword);\n\n            // console.log(arr);\n            // console.log(result);\n\n            // when suggestion enabled just forward keyword if term was found\n            // as long as the result is empty forward the pointer also\n\n            if (!suggest || !1 !== arr || !result.length) {\n\n                keyword = term;\n            }\n        } else {\n\n            arr = this.add_result(result, suggest, limit, offset, 1 === length, term);\n        }\n\n        if (arr) {\n\n            return (/** @type {Array<number|string>} */arr\n            );\n        }\n\n        // apply suggestions on last loop or fallback\n\n        if (suggest && index == length - 1) {\n\n            let length = result.length;\n\n            if (!length) {\n\n                if (depth) {\n\n                    // fallback to non-contextual search when no result was found\n\n                    depth = 0;\n                    index = -1;\n\n                    continue;\n                }\n\n                return result;\n            } else if (1 === length) {\n\n                // fast path optimization\n\n                return single_result(result[0], limit, offset);\n            }\n        }\n    }\n\n    return intersect(result, limit, offset, suggest);\n};\n\n/**\r\n * Returns an array when the result is done (to stop the process immediately),\r\n * returns false when suggestions is enabled and no result was found,\r\n * or returns nothing when a set was pushed successfully to the results\r\n *\r\n * @private\r\n * @param {Array} result\r\n * @param {Array} suggest\r\n * @param {number} limit\r\n * @param {number} offset\r\n * @param {boolean} single_term\r\n * @param {string} term\r\n * @param {string=} keyword\r\n * @return {Array<Array<string|number>>|boolean|undefined}\r\n */\n\nIndex.prototype.add_result = function (result, suggest, limit, offset, single_term, term, keyword) {\n    let word_arr = [],\n        arr = keyword ? this.ctx : this.map;\n\n\n    if (!this.optimize) {\n\n        arr = get_array(arr, term, keyword, this.bidirectional);\n    }\n\n    if (arr) {\n\n        let count = 0;\n        const arr_len = Math.min(arr.length, keyword ? this.resolution_ctx : this.resolution);\n\n        // relevance:\n        for (let x = 0, size = 0, tmp, len; x < arr_len; x++) {\n\n            tmp = arr[x];\n\n            if (tmp) {\n\n                if (this.optimize) {\n\n                    tmp = get_array(tmp, term, keyword, this.bidirectional);\n                }\n\n                if (offset) {\n\n                    if (tmp && single_term) {\n\n                        len = tmp.length;\n\n                        if (len <= offset) {\n\n                            offset -= len;\n                            tmp = null;\n                        } else {\n\n                            tmp = tmp.slice(offset);\n                            offset = 0;\n                        }\n                    }\n                }\n\n                if (tmp) {\n\n                    // keep score (sparse array):\n                    //word_arr[x] = tmp;\n\n                    // simplified score order:\n                    word_arr[count++] = tmp;\n\n                    if (single_term) {\n\n                        size += tmp.length;\n\n                        if (size >= limit) {\n\n                            // fast path optimization\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (count) {\n\n            if (single_term) {\n\n                // fast path optimization\n                // offset was already applied at this point\n\n                return single_result(word_arr, limit, 0);\n            }\n\n            result[result.length] = word_arr;\n            return;\n        }\n    }\n\n    // return an empty array will stop the loop,\n    // to prevent stop when using suggestions return a false value\n\n    return !suggest && word_arr;\n};\n\nfunction single_result(result, limit, offset) {\n\n    if (1 === result.length) {\n\n        result = result[0];\n    } else {\n\n        result = concat(result);\n    }\n\n    return offset || result.length > limit ? result.slice(offset, offset + limit) : result;\n}\n\nfunction get_array(arr, term, keyword, bidirectional) {\n\n    if (keyword) {\n\n        // the frequency of the starting letter is slightly less\n        // on the last half of the alphabet (m-z) in almost every latin language,\n        // so we sort downwards (https://en.wikipedia.org/wiki/Letter_frequency)\n\n        const swap = bidirectional && term > keyword;\n\n        arr = arr[swap ? term : keyword];\n        arr = arr && arr[swap ? keyword : term];\n    } else {\n\n        arr = arr[term];\n    }\n\n    return arr;\n}\n\nIndex.prototype.contain = function (id) {\n\n    return !!this.register[id];\n};\n\nIndex.prototype.update = function (id, content) {\n\n    return this.remove(id).add(id, content);\n};\n\n/**\r\n * @param {boolean=} _skip_deletion\r\n */\n\nIndex.prototype.remove = function (id, _skip_deletion) {\n\n    const refs = this.register[id];\n\n    if (refs) {\n\n        if (this.fastupdate) {\n\n            // fast updates performs really fast but did not fully cleanup the key entries\n\n            for (let i = 0, tmp; i < refs.length; i++) {\n\n                tmp = refs[i];\n                tmp.splice(tmp.indexOf(id), 1);\n            }\n        } else {\n\n            remove_index(this.map, id, this.resolution, this.optimize);\n\n            if (this.depth) {\n\n                remove_index(this.ctx, id, this.resolution_ctx, this.optimize);\n            }\n        }\n\n        _skip_deletion || delete this.register[id];\n\n        if (this.cache) {\n\n            this.cache.del(id);\n        }\n    }\n\n    return this;\n};\n\n/**\r\n * @param map\r\n * @param id\r\n * @param res\r\n * @param optimize\r\n * @param {number=} resolution\r\n * @return {number}\r\n */\n\nfunction remove_index(map, id, res, optimize, resolution) {\n\n    let count = 0;\n\n    if (is_array(map)) {\n\n        // the first array is the score array in both strategies\n\n        if (!resolution) {\n\n            resolution = Math.min(map.length, res);\n\n            for (let x = 0, arr; x < resolution; x++) {\n\n                arr = map[x];\n\n                if (arr) {\n\n                    count = remove_index(arr, id, res, optimize, resolution);\n\n                    if (!optimize && !count) {\n\n                        // when not memory optimized the score index should removed\n\n                        delete map[x];\n                    }\n                }\n            }\n        } else {\n\n            const pos = map.indexOf(id);\n\n            if (-1 !== pos) {\n\n                // fast path, when length is 1 or lower then the whole field gets deleted\n\n                if (1 < map.length) {\n\n                    map.splice(pos, 1);\n                    count++;\n                }\n            } else {\n\n                count++;\n            }\n        }\n    } else {\n\n        for (let key in map) {\n\n            count = remove_index(map[key], id, res, optimize, resolution);\n\n            if (!count) {\n\n                delete map[key];\n            }\n        }\n    }\n\n    return count;\n}\n\nIndex.prototype.searchCache = searchCache;\n\n\nIndex.prototype.export = exportIndex;\nIndex.prototype.import = importIndex;\n\n\napply_async(Index.prototype);","import Index from \"../index.js\";\n\nexport default function (data) {\n\n            data = data.data;\n\n            /** @type Index */\n            const index = self._index,\n                  args = data.args,\n                  task = data.task;\n\n\n            switch (task) {\n\n                        case \"init\":\n                                    const options = data.options || {},\n                                          factory = data.factory,\n                                          encode = options.encode;\n\n\n                                    options.cache = /* normalize: */ /* collapse: */ /* normalize: */\n\n                                    /* collapse: */ /* normalize: */ /* collapse: */ /* normalize: */ /* collapse: */ /* collapse: */!1;\n\n                                    if (encode && 0 === encode.indexOf(\"function\")) {\n                                                options.encode = Function(\"return \" + encode)();\n                                    }\n\n                                    if (factory) {\n\n                                                // export the FlexSearch global payload to \"self\"\n                                                Function(\"return \" + factory)()(self);\n\n                                                /** @type Index */\n                                                self._index = new self.FlexSearch.Index(options);\n\n                                                // destroy the exported payload\n                                                delete self.FlexSearch;\n                                    } else {\n\n                                                self._index = new Index(options);\n                                    }\n\n                                    break;\n\n                        default:\n                                    const id = data.id,\n                                          message = index[task].apply(index, args);\n\n                                    postMessage(\"search\" === task ? { id: id, msg: message } : { id: id });\n            }\n}","//import { promise as Promise } from \"../polyfill.js\";\nimport { create_object, is_function, is_object, is_string } from \"../common.js\";\nimport handler from \"./handler.js\";\n\nlet pid = 0;\n\n/**\r\n * @param {Object=} options\r\n * @constructor\r\n */\n\nfunction WorkerIndex(options) {\n\n    if (!(this instanceof WorkerIndex)) {\n\n        return new WorkerIndex(options);\n    }\n\n    let opt;\n\n    if (options) {\n\n        if (is_function(opt = options.encode)) {\n\n            options.encode = opt.toString();\n        }\n    } else {\n\n        options = {};\n    }\n\n    // the factory is the outer wrapper from the build\n    // we use \"self\" as a trap for node.js\n\n    let factory = (self || window)._factory;\n\n    if (factory) {\n\n        factory = factory.toString();\n    }\n\n    const is_node_js = \"undefined\" == typeof window && self.exports,\n          _self = this;\n\n    this.worker = create(factory, is_node_js, options.worker);\n    this.resolver = create_object();\n\n    if (!this.worker) {\n\n        return;\n    }\n\n    if (is_node_js) {\n\n        this.worker.on(\"message\", function (msg) {\n\n            _self.resolver[msg.id](msg.msg);\n            delete _self.resolver[msg.id];\n        });\n    } else {\n\n        this.worker.onmessage = function (msg) {\n\n            msg = msg.data;\n            _self.resolver[msg.id](msg.msg);\n            delete _self.resolver[msg.id];\n        };\n    }\n\n    this.worker.postMessage({\n\n        task: \"init\",\n        factory: factory,\n        options: options\n    });\n}\n\nexport default WorkerIndex;\n\nregister(\"add\");\nregister(\"append\");\nregister(\"search\");\nregister(\"update\");\nregister(\"remove\");\n\nfunction register(key) {\n\n    WorkerIndex.prototype[key] = WorkerIndex.prototype[key + \"Async\"] = function () {\n        const self = this,\n              args = [].slice.call(arguments),\n              arg = args[args.length - 1];\n\n        let callback;\n\n        if (is_function(arg)) {\n\n            callback = arg;\n            args.splice(args.length - 1, 1);\n        }\n\n        const promise = new Promise(function (resolve) {\n\n            setTimeout(function () {\n\n                self.resolver[++pid] = resolve;\n                self.worker.postMessage({\n\n                    task: key,\n                    id: pid,\n                    args: args\n                });\n            });\n        });\n\n        if (callback) {\n\n            promise.then(callback);\n            return this;\n        } else {\n\n            return promise;\n        }\n    };\n}\n\nfunction create(factory, is_node_js, worker_path) {\n\n    let worker;\n\n    try {\n\n        worker = is_node_js ? eval('new (require(\"worker_threads\")[\"Worker\"])(__dirname + \"/node/node.js\")') : factory ? new Worker(URL.createObjectURL(new Blob([\"onmessage=\" + handler.toString()], { type: \"text/javascript\" }))) : new Worker(is_string(worker_path) ? worker_path : \"worker/worker.js\", { type: \"module\" });\n    } catch (e) {}\n\n    return worker;\n}","/**!\r\n * FlexSearch.js\r\n * Author and Copyright: Thomas Wilkerling\r\n * Licence: Apache-2.0\r\n * Hosted by Nextapps GmbH\r\n * https://github.com/nextapps-de/flexsearch\r\n */\n\nimport Index from \"./index.js\";\nimport { DocumentInterface } from \"./type.js\";\nimport Cache, { searchCache } from \"./cache.js\";\nimport { create_object, is_array, is_string, is_object, parse_option, get_keys } from \"./common.js\";\nimport apply_async from \"./async.js\";\nimport { intersect, intersect_union } from \"./intersect.js\";\nimport { exportDocument, importDocument } from \"./serialize.js\";\nimport WorkerIndex from \"./worker/index.js\";\n\n/**\r\n * @constructor\r\n * @implements {DocumentInterface}\r\n * @param {Object=} options\r\n * @return {Document}\r\n */\n\nfunction Document(options) {\n\n    if (!(this instanceof Document)) {\n\n        return new Document(options);\n    }\n\n    const document = options.document || options.doc || options;\n    let opt;\n\n    this.tree = [];\n    this.field = [];\n    this.marker = [];\n    this.register = create_object();\n    this.key = (opt = document.key || document.id) && parse_tree(opt, this.marker) || \"id\";\n    this.fastupdate = parse_option(options.fastupdate, /* append: */ /* skip update: */ /* skip_update: */!0);\n\n    this.storetree = (opt = document.store) && !0 !== opt && [];\n    this.store = opt && create_object();\n\n\n    // TODO case-insensitive tags\n\n    this.tag = (opt = document.tag) && parse_tree(opt, this.marker);\n    this.tagindex = opt && create_object();\n\n\n    this.cache = (opt = options.cache) && new Cache(opt);\n\n    // do not apply cache again for the indexes\n\n    options.cache = !1;\n\n\n    this.worker = options.worker;\n\n\n    // this switch is used by recall of promise callbacks\n\n    this.async = !1;\n\n    /** @export */\n    this.index = parse_descriptor.call(this, options, document);\n}\n\nexport default Document;\n\n/**\r\n * @this Document\r\n */\n\nfunction parse_descriptor(options, document) {\n\n    const index = create_object();\n    let field = document.index || document.field || document;\n\n    if (is_string(field)) {\n\n        field = [field];\n    }\n\n    for (let i = 0, key, opt; i < field.length; i++) {\n\n        key = field[i];\n\n        if (!is_string(key)) {\n\n            opt = key;\n            key = key.field;\n        }\n\n        opt = is_object(opt) ? Object.assign({}, options, opt) : options;\n\n        if (this.worker) {\n\n            index[key] = new WorkerIndex(opt);\n\n            if (!index[key].worker) {\n\n                this.worker = !1;\n            }\n        }\n\n        if (!this.worker) {\n\n            index[key] = new Index(opt, this.register);\n        }\n\n        this.tree[i] = parse_tree(key, this.marker);\n        this.field[i] = key;\n    }\n\n    if (this.storetree) {\n\n        let store = document.store;\n\n        if (is_string(store)) {\n\n            store = [store];\n        }\n\n        for (let i = 0; i < store.length; i++) {\n\n            this.storetree[i] = parse_tree(store[i], this.marker);\n        }\n    }\n\n    return index;\n}\n\nfunction parse_tree(key, marker) {\n\n    const tree = key.split(\":\");\n    let count = 0;\n\n    for (let i = 0; i < tree.length; i++) {\n\n        key = tree[i];\n\n        if (0 <= key.indexOf(\"[]\")) {\n\n            key = key.substring(0, key.length - 2);\n\n            if (key) {\n\n                marker[count] = !0;\n            }\n        }\n\n        if (key) {\n\n            tree[count++] = key;\n        }\n    }\n\n    if (count < tree.length) {\n\n        tree.length = count;\n    }\n\n    return 1 < count ? tree : tree[0];\n}\n\n// TODO support generic function created from string when tree depth > 1\n\nfunction parse_simple(obj, tree) {\n\n    if (is_string(tree)) {\n\n        obj = obj[tree];\n    } else {\n\n        for (let i = 0; obj && i < tree.length; i++) {\n\n            obj = obj[tree[i]];\n        }\n    }\n\n    return obj;\n}\n\n// TODO support generic function created from string when tree depth > 1\n\nfunction store_value(obj, store, tree, pos, key) {\n\n    obj = obj[key];\n\n    // reached target field\n\n    if (pos === tree.length - 1) {\n\n        // store target value\n\n        store[key] = obj;\n    } else if (obj) {\n\n        if (is_array(obj)) {\n\n            store = store[key] = Array(obj.length);\n\n            for (let i = 0; i < obj.length; i++) {\n\n                // do not increase pos (an array is not a field)\n                store_value(obj, store, tree, pos, i);\n            }\n        } else {\n\n            store = store[key] || (store[key] = create_object());\n            key = tree[++pos];\n\n            store_value(obj, store, tree, pos, key);\n        }\n    }\n}\n\nfunction add_index(obj, tree, marker, pos, index, id, key, _append) {\n\n    obj = obj[key];\n\n    if (obj) {\n\n        // reached target field\n\n        if (pos === tree.length - 1) {\n\n            // handle target value\n\n            if (is_array(obj)) {\n\n                // append array contents so each entry gets a new scoring context\n\n                if (marker[pos]) {\n\n                    for (let i = 0; i < obj.length; i++) {\n\n                        index.add(id, obj[i], !0, !0);\n                    }\n\n                    return;\n                }\n\n                // or join array contents and use one scoring context\n\n                obj = obj.join(\" \");\n            }\n\n            index.add(id, obj, _append, !0);\n        } else {\n\n            if (is_array(obj)) {\n\n                for (let i = 0; i < obj.length; i++) {\n\n                    // do not increase index, an array is not a field\n\n                    add_index(obj, tree, marker, pos, index, id, i, _append);\n                }\n            } else {\n\n                key = tree[++pos];\n\n                add_index(obj, tree, marker, pos, index, id, key, _append);\n            }\n        }\n    }\n}\n\n/**\r\n *\r\n * @param id\r\n * @param content\r\n * @param {boolean=} _append\r\n * @returns {Document|Promise}\r\n */\n\nDocument.prototype.add = function (id, content, _append) {\n\n    if (is_object(id)) {\n\n        content = id;\n        id = parse_simple(content, this.key);\n    }\n\n    if (content && (id || 0 === id)) {\n\n        if (!_append && this.register[id]) {\n\n            return this.update(id, content);\n        }\n\n        for (let i = 0, tree, field; i < this.field.length; i++) {\n\n            field = this.field[i];\n            tree = this.tree[i];\n\n            if (is_string(tree)) {\n\n                tree = [tree];\n            }\n\n            add_index(content, tree, this.marker, 0, this.index[field], id, tree[0], _append);\n        }\n\n        if (this.tag) {\n            let tag = parse_simple(content, this.tag),\n                dupes = create_object();\n\n\n            if (is_string(tag)) {\n\n                tag = [tag];\n            }\n\n            for (let i = 0, key, arr; i < tag.length; i++) {\n\n                key = tag[i];\n\n                if (!dupes[key]) {\n\n                    dupes[key] = 1;\n                    arr = this.tagindex[key] || (this.tagindex[key] = []);\n\n                    if (!_append || !arr.includes(id)) {\n\n                        arr[arr.length] = id;\n\n                        // add a reference to the register for fast updates\n\n                        if (this.fastupdate) {\n\n                            const tmp = this.register[id] || (this.register[id] = []);\n                            tmp[tmp.length] = arr;\n                        }\n                    }\n                }\n            }\n        }\n\n        // TODO: how to handle store when appending contents?\n\n        if (this.store && (!_append || !this.store[id])) {\n\n            let store;\n\n            if (this.storetree) {\n\n                store = create_object();\n\n                for (let i = 0, tree; i < this.storetree.length; i++) {\n\n                    tree = this.storetree[i];\n\n                    if (is_string(tree)) {\n\n                        store[tree] = content[tree];\n                    } else {\n\n                        store_value(content, store, tree, 0, tree[0]);\n                    }\n                }\n            }\n\n            this.store[id] = store || content;\n        }\n    }\n\n    return this;\n};\n\nDocument.prototype.append = function (id, content) {\n\n    return this.add(id, content, !0);\n};\n\nDocument.prototype.update = function (id, content) {\n\n    return this.remove(id).add(id, content);\n};\n\nDocument.prototype.remove = function (id) {\n\n    if (is_object(id)) {\n\n        id = parse_simple(id, this.key);\n    }\n\n    if (this.register[id]) {\n\n        for (let i = 0; i < this.field.length; i++) {\n\n            // workers does not share the register\n\n            this.index[this.field[i]].remove(id, !this.worker);\n\n            if (this.fastupdate) {\n\n                // when fastupdate was enabled all ids are removed\n\n                break;\n            }\n        }\n\n        if (this.tag) {\n\n            // when fastupdate was enabled all ids are already removed\n\n            if (!this.fastupdate) {\n\n                for (let key in this.tagindex) {\n                    const tag = this.tagindex[key],\n                          pos = tag.indexOf(id);\n\n\n                    if (-1 !== pos) {\n\n                        if (1 < tag.length) {\n\n                            tag.splice(pos, 1);\n                        } else {\n\n                            delete this.tagindex[key];\n                        }\n                    }\n                }\n            }\n        }\n\n        if (this.store) {\n\n            delete this.store[id];\n        }\n\n        delete this.register[id];\n    }\n\n    return this;\n};\n\n/**\r\n * @param {!string|Object} query\r\n * @param {number|Object=} limit\r\n * @param {Object=} options\r\n * @param {Array<Array>=} _resolve For internal use only.\r\n * @returns {Promise|Array}\r\n */\n\nDocument.prototype.search = function (query, limit, options, _resolve) {\n\n    if (!options) {\n\n        if (!limit && is_object(query)) {\n\n            options = /** @type {Object} */query;\n            query = \"\";\n        } else if (is_object(limit)) {\n\n            options = /** @type {Object} */limit;\n            limit = 0;\n        }\n    }\n\n    let result = [],\n        result_field = [],\n        pluck,\n        enrich,\n        field,\n        tag,\n        bool,\n        offset,\n        count = 0;\n\n\n    if (options) {\n\n        if (is_array(options)) {\n\n            field = options;\n            options = null;\n        } else {\n\n            query = options.query || query;\n            pluck = options.pluck;\n            field = pluck || options.index || options.field /*|| (is_string(options) && [options])*/;\n            tag = options.tag;\n            enrich = this.store && options.enrich;\n            bool = \"and\" === options.bool;\n            limit = options.limit || limit || 100;\n            offset = options.offset || 0;\n\n            if (tag) {\n\n                if (is_string(tag)) {\n\n                    tag = [tag];\n                }\n\n                // when tags is used and no query was set,\n                // then just return the tag indexes\n\n                if (!query) {\n\n                    for (let i = 0, res; i < tag.length; i++) {\n\n                        res = get_tag.call(this, tag[i], limit, offset, enrich);\n\n                        if (res) {\n\n                            result[result.length] = res;\n                            count++;\n                        }\n                    }\n\n                    return count ? result : [];\n                }\n            }\n\n            if (is_string(field)) {\n\n                field = [field];\n            }\n        }\n    }\n\n    field || (field = this.field);\n    bool = bool && (1 < field.length || tag && 1 < tag.length);\n\n    const promises = !_resolve && (this.worker || this.async) && [];\n\n    // TODO solve this in one loop below\n\n    for (let i = 0, res, key, len; i < field.length; i++) {\n\n        let field_options;\n\n        key = field[i];\n\n        if (!is_string(key)) {\n\n            field_options = key;\n            key = field_options.field;\n            query = field_options.query || query;\n            limit = field_options.limit || limit;\n            enrich = field_options.enrich || enrich;\n        }\n\n        if (promises) {\n\n            promises[i] = this.index[key].searchAsync(query, limit, field_options || options);\n\n            // just collect and continue\n\n            continue;\n        } else if (_resolve) {\n\n            res = _resolve[i];\n        } else {\n\n            // inherit options also when search? it is just for laziness, Object.assign() has a cost\n\n            res = this.index[key].search(query, limit, field_options || options);\n        }\n\n        len = res && res.length;\n\n        if (tag && len) {\n\n            const arr = [];\n            let count = 0;\n\n            if (bool) {\n\n                // prepare for intersection\n\n                arr[0] = [res];\n            }\n\n            for (let y = 0, key, res; y < tag.length; y++) {\n\n                key = tag[y];\n                res = this.tagindex[key];\n                len = res && res.length;\n\n                if (len) {\n\n                    count++;\n                    arr[arr.length] = bool ? [res] : res;\n                }\n            }\n\n            if (count) {\n\n                if (bool) {\n\n                    res = intersect(arr, limit || 100, offset || 0);\n                } else {\n\n                    res = intersect_union(res, arr);\n                }\n\n                len = res.length;\n            }\n        }\n\n        if (len) {\n\n            result_field[count] = key;\n            result[count++] = res;\n        } else if (bool) {\n\n            return [];\n        }\n    }\n\n    if (promises) {\n\n        const self = this;\n\n        // anyone knows a better workaround of optionally having async promises?\n        // the promise.all() needs to be wrapped into additional promise,\n        // otherwise the recursive callback wouldn't run before return\n\n        return new Promise(function (resolve) {\n\n            Promise.all(promises).then(function (result) {\n\n                resolve(self.search(query, limit, options, result));\n            });\n        });\n    }\n\n    if (!count) {\n\n        // fast path \"not found\"\n\n        return [];\n    }\n\n    if (pluck && (!enrich || !this.store)) {\n\n        // fast path optimization\n\n        return result[0];\n    }\n\n    for (let i = 0, res; i < result_field.length; i++) {\n\n        res = result[i];\n\n        if (res.length) {\n\n            if (enrich) {\n\n                res = apply_enrich.call(this, res);\n            }\n        }\n\n        if (pluck) {\n\n            return res;\n        }\n\n        result[i] = {\n\n            field: result_field[i],\n            result: res\n        };\n    }\n\n    return result;\n};\n\n/**\r\n * @this Document\r\n */\n\nfunction get_tag(key, limit, offset) {\n    let res = this.tagindex[key],\n        len = res && res.length - offset;\n}\n\n/**\r\n * @this Document\r\n */\n\nfunction apply_enrich(res) {\n\n    const arr = Array(res.length);\n\n    for (let x = 0, id; x < res.length; x++) {\n\n        id = res[x];\n\n        arr[x] = {\n\n            id: id,\n            doc: this.store[id]\n        };\n    }\n\n    return arr;\n}\n\nDocument.prototype.contain = function (id) {\n\n    return !!this.register[id];\n};\n\nDocument.prototype.get = function (id) {\n\n    return this.store[id];\n};\n\nDocument.prototype.set = function (id, data) {\n\n    this.store[id] = data;\n    return this;\n};\n\n\nDocument.prototype.searchCache = searchCache;\n\n\nDocument.prototype.export = exportDocument;\nDocument.prototype.import = importDocument;\n\n\napply_async(Document.prototype);","import FlexSearchDocument from 'flexsearch/dist/module/document';\nimport { concat, each, flatMap, flatMapDeep, slice, uniq, uniqBy } from 'lodash';\nimport { defineStore } from 'pinia';\nimport ApiHelper from 'plugins/api';\nimport useRouter from 'plugins/router';\nimport { pinia } from 'plugins/store/index';\nimport { computed, ref } from 'vue';\n\ninterface FlexSearchDocument {\n  id: string;\n  field: any;\n}\n\ninterface Searchstore extends Obj {\n  debug: boolean,\n  deepLinked: boolean,\n  url?: string,\n  loaded: boolean,\n  // will need to be typed by project.\n  data?: any[],\n  searchIndex?: any,\n  options: {\n    minQueryLength: number,\n    documentIndex: string[],\n  },\n  pagination: {\n    page: number,\n    perPage: number,\n    max: number,\n  },\n  query?: string,\n  // will need to be typed by project.\n  result?: any[],\n}\n\nconst useStore = defineStore('Search', () => {\n  const state = ref<Searchstore>({\n    // load moc data directly\n    debug: true,\n    // in case we need it, super usefull inside storybook\n    deepLinked: false,\n    // api url if needed can use `window.__SEARCH` instead of an api.\n    url: 'news',\n    \n    loaded: false,\n    data: undefined,\n    searchIndex: undefined,\n    options: {\n      // min query length for actual search\n      minQueryLength: 3,\n      // document field to search in\n      documentIndex: ['title', 'brand', 'category', 'description'],\n    },\n    pagination: {\n      page: 1,\n      perPage: 10,\n      max: 1,\n    },\n    query: undefined,\n    result: undefined\n  })\n\n  const init = async (/* url:string */) => {\n    return new Promise(resolve => {\n      if (state.value.loaded) {\n        return resolve(state.value.data)\n      }\n      if (state.value.debug) {\n        return resolve(\n          import(/* webpackChunkName: \"moc-search\" */`./moc/huge.json`).then((Module: any) => Module.default as Array<any> )\n        )\n      }\n\n      if (window.__SEARCH) {\n        return resolve(window.__SEARCH as Array<any>)\n      }\n\n      if (state.value.url) {\n        return resolve(ApiHelper.get(state.value.url).then(({ data }: any) => {\n          return data as Array<any>\n        }))\n      }\n      return resolve([]);\n    })\n    .then((data?: any) => {\n      state.value.loaded = true\n      state.value.data = data || undefined;\n      return data;\n    })\n    .then(createSearchIndex)\n  }\n\n  const createSearchIndex = async (/* url:string */) => {\n    return new Promise((resolve) => {\n      if (state.value.searchIndex) {\n        resolve(state.value.searchIndex);\n        return;\n      }\n\n      // init lib (will populate later)\n      const searchIndex = new FlexSearchDocument({\n        preset: 'match',\n        async: true,\n        cache: true,\n        tokenize: 'full',\n        charset: 'latin:advanced',\n        resolution: 5,\n        context: { \n          resolution: 5,\n          depth: 2,\n          bidirectional: true,\n          minlength: 3,\n        },\n        document: {\n          id: 'id',\n          index: state.value.options.documentIndex,\n          store: true,\n          enrich: true,\n          suggest: true,\n        },\n      });\n\n      // add items to searchIndex\n      setTimeout(() => {\n        // searchIndex.add(state.value.data);\n        each(state.value.data, (entry) => {\n          // searchIndex.add(entry.id, entry);\n          searchIndex.add(entry);\n        })\n        state.value.searchIndex = searchIndex;\n        setDefaultFilters();\n        resolve(searchIndex);\n      }, 100);\n    });\n  }\n\n\n  // Router thing\n  const setDefaultFilters = () => {\n    const routeQuery = useRouter().currentRoute.value.query\n\n    if (routeQuery.page) {\n      state.value.pagination.page = parseInt(routeQuery.page as string, 10) || 1;\n    }\n    delete routeQuery.page;\n\n    if (routeQuery.q) {\n      state.value.query = routeQuery.q as string;\n      search(routeQuery.q as string)\n    }\n  }\n\n  const syncRouterQuery = () => {\n    if (!state.value.deepLinked) return;\n    const query:any = {};\n    if (state.value.query) {\n      query.q = state.value.query;\n    } else {\n      delete query.q;\n    }\n    if (state.value.pagination.page) {\n      query.page = state.value.pagination.page;\n    } else {\n      delete query.page;\n    }\n    useRouter().replace({query: query})\n  }\n\n  const search = async (query = '', options?:any) => {\n    // wow - this mix sync/async works ;)\n    const searchIndex = state.value.searchIndex || await init;\n\n    if (!query) {\n      return clear();\n    }\n\n    const result = await searchIndex.search(query, 1000000000, {\n      limit: 1000000000,\n      enrich: true,\n      bool: 'or',\n      ...options\n    });\n    \n    if(!result || result.length == 0){\n      return clear()\n    }\n\n    // compute only doc, nothing else.\n    const arrComputed = uniqBy(flatMap(result, (entry) => {\n      return flatMapDeep(entry.result, 'doc'); \n    }), 'id');\n\n    state.value.query = query;\n    return state.value.result = arrComputed;\n  }\n\n  const clear = () => {\n    state.value.query = undefined;\n    state.value.pagination.page = 1;\n    state.value.pagination.max = 1;\n    return state.value.result = undefined;\n  }\n\n  const autocomplete = async (query = '', options?:any) => {\n    // wow - this mix sync/async works ;)\n    const searchIndex = state.value.searchIndex || await init;\n    \n    const result = await searchIndex.search(query, 5, {\n      limit: 5, // limit By field....\n      suggest: true,\n      enrich: true,\n      bool: 'or',\n      ...options\n    });\n\n    if(!result || result.length == 0) return undefined;\n\n    // compute only doc, nothing else.\n    let arrComputed:string[] = [];\n    each(result, (entryKey) => {\n      // autocomplete inside the result field..\n      // const field = `doc.${entryKey.field}`;\n      // const value:string[] = flatMapDeep(entryKey.result, field); \n      // but hey it's easier if we get only the title right ?\n      const field = `doc.title`;\n      const value:string[] = flatMapDeep(entryKey.result, field); \n\n      arrComputed = concat(arrComputed, value);\n    })\n    // actual limit\n    arrComputed = slice(uniq(arrComputed), 0, 5);\n\n    return arrComputed;\n  }\n\n\n  const setPagination = (page: number) => {\n    state.value.pagination.page = page;\n  }\n  \n  const prevPagination = () => {\n    if (state.value.pagination.page - 1 === 0) {\n      state.value.pagination.page = 1\n    } else {\n      state.value.pagination.page = state.value.pagination.page - 1;\n    }\n  }\n\n  const nextPagination = () => {\n    if (state.value.pagination.page + 1 > state.value.pagination.max) {\n      state.value.pagination.page = state.value.pagination.max\n    } else {\n      state.value.pagination.page = state.value.pagination.page + 1;\n    }\n  }\n\n\n  // const cards = computed(() => state.value.items)\n  const paginated = computed(() => {\n    const items = state.value.result;\n\n    if (!items) {\n      syncRouterQuery()\n      return undefined;\n    }\n\n    const { page, perPage } = state.value.pagination;\n    const pageStart = (page - 1) * perPage;\n    const pageEnd = pageStart + perPage;\n    // in case we want a real pagination..\n    // const paginated = slice(items, pageStart, pageEnd);\n    // case with a \"load more\" system append to current page result.\n    const paginated = slice(items, 0, pageEnd);\n\n    // recompute max page from current filtered items\n    state.value.pagination.max = Math.ceil(items.length / state.value.pagination.perPage)\n\n    syncRouterQuery()\n\n    return paginated;\n  })\n\n\n  return {\n    state,\n\n    // Action\n    init,\n    search,\n    clear,\n    autocomplete,\n\n    // pagination\n    setPagination,\n    prevPagination,\n    nextPagination,\n\n    // Getters\n    options: computed(() => state.value.options),\n    paginated,\n    pagination: computed(() => state.value.pagination)\n  }\n})\nexport const store = useStore(pinia);\nexport default store;\n","<docs>\n  # UiSearch\n  > Search module\n  \n  @author Kevin Bastien <kevin@kffein.com>\n</docs>\n\n<script lang=\"ts\">\nimport { onClickOutside, templateRef } from '@vueuse/core';\nimport { FORM_RULES, FORM_STATUS, KoddeinField, KoddeinForm, createFormModel } from 'components/UiKit/KoddeinVueForm';\nimport { store as i18nStore } from 'plugins/i18n/store';\nimport useFlow from 'utils/flow';\nimport { defineComponent, computed, reactive, toRefs } from 'vue';\nimport { useI18n } from 'vue-i18n';\nimport { useRoute, useRouter } from 'vue-router';\nimport Icon from './assets/icon.svg?raw';\nimport { store as SearchStore } from './store';\n\ninterface Data {\n  model: any,\n  formState: FormStatusType,\n  search: {\n    busy: boolean,\n    error: boolean,\n    value?: string,\n    autocomplete?: Array<any>,\n  }\n}\n\nconst UiSearch = defineComponent({\n  name: 'UiSearch',\n  components: {\n    KoddeinField, \n    KoddeinForm,\n  },\n  props: {\n    // full = search bar + result /// !full = search bar only -> redirect to search page with query ?\n    full: {\n      type: Boolean,\n      default: true,\n    },\n    // \n    autocomplete: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  setup(props) {\n    const {t} = useI18n()\n    const i18nLocale: Koddein.Locale = i18nStore.locale as Koddein.Locale;\n    const { options } = toRefs(SearchStore.state);\n    const route = useRoute();\n    const router = useRouter();\n    const suggestionElem = templateRef<HTMLElement | null>('suggestionElem', null)\n\n    const data:Data = reactive(\n      {\n        model: createFormModel({\n          search: {\n            type: 'text',\n            validations: [FORM_RULES.MIN],\n            min: 3,\n            required: false,\n          },\n        }),\n        formState: FORM_STATUS.PRISTINE as FormStatusType,\n        search: {\n          busy: false,\n          error: false,\n          autocomplete: undefined,\n        }\n      }\n    );\n\n    onClickOutside(suggestionElem, () => {\n      data.search.autocomplete = undefined;\n    })\n\n    const { ready } = useFlow({\n      async load(){\n        data.model.search.value = route.query.q;\n        const storeIndex: any = await SearchStore.init();\n        return storeIndex;\n      },\n    })\n\n    const submit = async (/* token -> for recaptcha, if backendrequest ?*/) => {\n      if (props.full) {\n        return await SearchStore.search(data.model.search.value).then((result) => {\n          data.search.busy = false;\n          data.search.error = result ? false : true;\n          data.search.autocomplete = undefined;\n        })\n      // in case of a search bar inside the menu... redirect to the desired page.\n      } else {\n        return router.push({path: `/${i18nLocale.name}`, query: {q: data.model.search.value}})\n      }\n    }\n    \n    const suggestion = async () => {\n      data.model.search.error = '';\n      data.search.autocomplete = undefined;\n      \n      if (props.autocomplete && !data.search.busy && data.model.search.value && data.model.search.value.length >= options.value.minQueryLength) {\n        return await SearchStore.autocomplete(data.model.search.value).then((result) => {\n          data.search.busy = false;\n          data.search.autocomplete = result;\n        })\n      }\n    }\n\n    const searchSuggestion = (value:string) => {\n      data.model.search.value = value;\n      submit();\n    }\n\n    const nextPage = () => {\n      SearchStore.nextPagination();\n    }\n\n    return {\n      t,\n      ...toRefs(data), //data\n      ready,\n      submit,\n      suggestion,\n      searchSuggestion,\n      nextPage,\n      pagination: computed(()=>SearchStore.pagination),\n      result: computed(()=>SearchStore.paginated),\n      Icon,\n    }\n  }\n});\nexport default UiSearch;\n</script>\n  \n<template>\n  <section v-if=\"ready\" :class=\"`UiSearch ${full ? '-full' : ''}`\">\n    <h2 v-if=\"full\"\n        class=\"title\"\n        v-text=\"t('LABELS.search.label')\"\n    />\n    <KoddeinForm v-if=\"model\"\n                 key=\"searchForm\"\n                 :model=\"model\"\n                 :labels=\"{\n                   submit: ' ',\n                 }\"\n                 :icons=\"{\n                   submit: Icon,\n                 }\"\n                 :recaptcha=\"false\"\n                 :flash=\"false\"\n                 :reset=\"false\"\n                 class=\"form\"\n                 submit-icon\n                 :on-send=\"submit\"\n                 @update=\"(data:any)=>model = data\"\n                 @status=\"(status:FormStatusType)=>formState = status\"\n    >\n      <KoddeinField v-model=\"model.search.value\"\n                    v-bind=\"model.search\"\n                    @update:model-value=\"suggestion\"\n                    @focus=\"formState = 'PRISTINE'\"\n      />\n    </KoddeinForm>\n    <div class=\"content\">\n      <transition name=\"fade\">\n        <div v-if=\"search.autocomplete\"\n             ref=\"suggestionElem\"\n             class=\"suggestion\"\n        >\n          <!-- <span class=\"label\" v-text=\"t('LABELS.search.suggest')\" /> -->\n          <ul>\n            <li v-for=\"entry in search.autocomplete\"\n                :key=\"`result-suggestion-${entry}`\"\n                class=\"suggestion-entry\"\n                @click=\"searchSuggestion(entry)\"\n                v-text=\"entry\"\n            />\n          </ul>\n        </div>\n      </transition>\n  \n      <transition name=\"fade\">\n        <div v-if=\"full && result && result.length > 0\"\n             class=\"result\"\n        >\n          <h3 class=\"subtitle\" v-text=\"t('LABELS.search.result', result.length)\" />\n          <transition-group class=\"entries\"\n                            name=\"list\"\n                            tag=\"ul\"\n          >\n            <li v-for=\"entry in result\"\n                :key=\"`result-search-${entry.id}`\"\n                class=\"entry\"\n            >\n              <span class=\"border -top\" />\n              <span class=\"label\">{{ entry.title }}</span>\n              <span class=\"border -bottom\" />\n            </li>\n          </transition-group>\n          <div v-if=\"pagination && pagination.page < pagination.max\" class=\"pagination\">\n            <ui-button :label=\"t('LABELS.search.load_more')\"\n                       theme=\"primary\"\n                       @click=\"nextPage\"\n            />\n          </div>\n        </div>\n      </transition>\n      <transition name=\"fade\">\n        <div v-if=\"full && search.error\"\n             class=\"result\"\n        >\n          <p class=\"error\" v-text=\"t('LABELS.search.error')\" />\n        </div>\n      </transition>\n    </div>\n  </section>\n</template>\n\n<style lang=\"stylus\">\n  .UiSearch\n    &.-full\n      rp(y-padding, 100px 50px)\n  \n    .form\n      position relative\n      .input\n        padding-right 85px\n        rp(height, 60px 50px)\n      .placeholder\n        rp(margin-top, 3px 0)\n      .KoddeinSubmit\n        absolute right 20px top 0\n        margin-top 0\n        padding-top 10px\n        padding-bottom 10px\n        background transparent\n        rp(height, 60px 50px)\n        .icon\n          margin-left 0\n      .success\n        display none\n\n    .title\n      f-style(h2)\n      rp(margin-bottom, 20px 10px)\n\n    .result\n      rp(padding-top, 50px 40px)\n\n  .content\n    position relative\n\n  .suggestion\n    absolute top 0 left 0\n    border 1px solid $c-f-border-focus\n    border-radius 10px\n    overflow hidden\n    z-index 50\n\n  .suggestion-entry\n    pointer-events pointer\n    color $c-black\n    background $c-white\n    trans()\n    +layout(desktop)\n      padding $form_input_padding\n    +layout(mobile)\n      padding $form_input_padding_m\n    +hover()\n      background $c-black\n      color $c-white\n\n  .subtitle\n    f-style(h4)\n    margin-bottom 20px\n  \n  .entry\n    position relative\n    padding 30px 0\n  \n    .border\n      absolute top 0 left 0 right 0\n      transform-origin left center\n      height 1px\n      background $c-black\n      &.-bottom\n        top auto\n        bottom -1px\n  \n  .pagination\n    margin-top 20px\n\n  .fade-leave-active\n  .fade-enter-active\n    trans()\n  .fade-enter-from\n    opacity 0\n  .fade-leave-to\n    opacity 0\n  \n  .list-enter-active\n  .list-leave-active\n    trans()\n  .list-enter-from\n  .list-leave-to\n    opacity 0\n    transform translateX(30px)\n</style>\n  "],"file":"assets/index-rKb_IjeI.js"}
{"version":3,"file":"LibraryScene-DBRHoEwe.js","sources":["../../src/vue/node_modules/lodash/_baseClamp.js","../../src/vue/node_modules/lodash/clamp.js","../../src/vue/src/pages/Home/blocks/webgl/assets.ts","../../src/vue/src/pages/Home/blocks/webgl/items.ts","../../src/vue/src/pages/Home/blocks/webgl/LibraryScene.ts"],"sourcesContent":["/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n","var baseClamp = require('./_baseClamp'),\n    toNumber = require('./toNumber');\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n","const textures = [\n  {\n    id: \"foreground\",\n    width: 2090,\n    height: 906,\n    scale: 1.42,\n  },\n  {\n    id: \"sideLeft\",\n    width: 1098,\n    height: 1956,\n    scale: 1.55,\n  },\n  {\n    id: \"sideRight\",\n    width: 1098,\n    height: 1956,\n    scale: 1.55,\n  },\n  {\n    id: \"background\",\n    width: 1783,\n    height: 1431,\n    scale: 1.73,\n  }\n];\n\nexport { textures };\n\n","const textures = [\n  {\n    id: \"box\",\n    width: 794,\n    height: 503,\n    scale: 1.35,\n  },\n  {\n    id: \"record\",\n    width: 835,\n    height: 430,\n    scale: 1.4,\n  },\n  {\n    id: \"partitions\",\n    width: 670,\n    height: 360,\n    scale: 1,\n  },\n  {\n    id: \"typewriter\",\n    width: 790,\n    height: 524,\n    scale: 1.45,\n  },\n  {\n    id: \"poster\",\n    width: 353,\n    height: 407,\n    scale: 0.9,\n  },\n  {\n    id: \"carnet\",\n    width: 292,\n    height: 430,\n    scale: 0.8,\n  },\n  {\n    id: \"livre\",\n    width: 279,\n    height: 459,\n    scale: 1.1,\n  },\n  {\n    id: \"violon\",\n    width: 312,\n    height: 644,\n    scale: 1.8,\n  },\n\n];\n\nexport { textures };\n\n","import { store as appStore } from 'plugins/store/app';\nimport { store as interfaceStore } from 'store/interface';\n\nimport { WebGLRenderParams, WebGLSceneOptions } from \"components/WebGL/gl\";\nimport { WebGLScene } from 'components/WebGL/three/glScene';\nimport { store as loaderStore } from 'components/ui/Loader/store';\nimport { gsap } from \"gsap\"; // Import GSAP at the top\nimport { clamp, each, find } from \"lodash\";\nimport { damp, damp3 } from \"maath/easing\";\nimport emitter, { EVENTS } from \"plugins/store/events\";\nimport { mainWebGLRenderer } from \"plugins/webgl/three\";\nimport { Group, Mesh, MeshBasicMaterial, Object3D, Object3DEventMap, PlaneGeometry, Raycaster, SRGBColorSpace, ShaderMaterial, Vector2 } from \"three\";\nimport { textures } from \"./assets\";\nimport { textures as texturesItem } from './items'; // Assuming textures are exported from item.ts\n\nconst commonGeometry = new PlaneGeometry(1, 1);\nconst commonMaterial = new MeshBasicMaterial({ transparent: true });\n\nexport default class extends WebGLScene {\n  private raycaster: Raycaster = new Raycaster();\n  isUserActive = false;\n  userActivityTimeout: ReturnType<typeof setTimeout> | null = null;\n  userActivityTl?:GSAPTimeline;\n  sceneIndex: number;\n  handlers: Obj;\n  mouse: Point = { x: 0, y: 0 };\n  touchActive = false;\n  disableClick = false;\n  mouseOffset: Point = { x: 20, y: 15 };\n  name: string = \"LibraryScene\";\n  ready:boolean = false;\n  touchTimers = {\n    start: 0,\n    end: 0,\n    tap: false\n  }\n\n  constructor(options: WebGLSceneOptions) {\n    // new glScene(options)\n    super(options);\n\n    this.handlers = {\n      click: this.handleClick.bind(this),\n      move: this.onMouseMove.bind(this),\n      start: this.handleTouchStart.bind(this),\n      end: this.onTouchEnd.bind(this),\n      tmove: this.onTouchMove.bind(this),\n    }\n    this.sceneIndex = 1;\n    return this;\n  }\n  //stop user activity\n  stopUserActivity() {\n    if (this.userActivityTl) {\n      this.userActivityTl.kill();\n      this.isUserActive = true;\n    }\n  }\n  \n  // Event handler function\n  resetUserActivity() {\n    \n    this.isUserActive = true;\n    this.stopUserActivity();\n    \n    if(appStore.introSeen) return;\n    \n    this.userActivityTl = gsap.timeline({\n      repeat:-1,\n      repeatDelay:2,\n      delay: 3.5\n    })\n      .add( () => {\n        this.isUserActive = false;\n      }, 0)\n      .add( () => {\n        this.isUserActive = true;\n      }, 1);\n  }\n\n  build() {\n\n    const group = new Group();\n    group.name = \"mainGroup\";\n    group.position.z = 0;\n\n    const groupForeground = new Group();\n    groupForeground.name = \"foregroundGroup\";\n    // groupForeground.position.set(-0.2, -1.55, 0)\n    groupForeground.userData.position = groupForeground.position.clone();\n\n    const groupLeftSide = new Group();\n    groupLeftSide.name = \"leftSideGroup\";\n    // groupLeftSide.position.set((-this.sceneSize.width / 2) - 0.1, 0.1, 0)\n    groupLeftSide.userData.position = groupLeftSide.position.clone();\n\n    const groupRightSide = new Group();\n    groupRightSide.name = \"rightSideGroup\";\n    // groupRightSide.position.set((this.sceneSize.width / 2) + 0.55, 0.1, 0);\n    groupRightSide.userData.position = groupRightSide.position.clone();\n\n    const groupBackground = new Group();\n    groupBackground.name = \"backgroundGroup\";\n    // groupBackground.position.set(0, 0.5, 0)\n    groupBackground.userData.position = groupBackground.position.clone();\n\n    const groupObject = new Group();\n    groupObject.name = \"groupObject\";\n    groupObject.position.z = 0;\n    this.scene.add(group);\n    this.scene.add(groupObject);\n    this.scene.add(groupBackground);\n    this.scene.add(groupLeftSide);\n    this.scene.add(groupRightSide);\n    this.scene.add(groupForeground);\n\n    // Load all textures\n    const assets = ['background', 'sideLeft', 'sideRight', 'foreground'];\n    const mesh_positions = [\n      { x: 0, y: 0, z: -5, scx: 0., scy: 0.22 },\n      { x: -1, y: 0, z: -2, scx: 1.1, scy: 0.12 }, // Adjusted for sideLeft\n      { x: 1, y: 0, z: -2, scx: -1.2, scy: 0.12 }, // Adjusted for sideRight\n      { x: 0, y: -1, z: -1, scx: 0., scy: 1.22 },\n    ];\n\n    assets.forEach((id, index) => {\n      const texObj = find(textures, t => t.id === id);\n      if (texObj) {\n        const data = loaderStore.getTexture(texObj.id);\n        data.colorSpace = SRGBColorSpace;\n        const material = commonMaterial.clone();\n        material.map = data;\n        material.opacity = 1;\n        material.toneMapped = false;\n\n        const mesh = new Mesh(commonGeometry, material);\n        mesh.userData.position_ref = mesh_positions[index];\n        mesh.name = texObj.id;\n        mesh.userData.scale = texObj.scale;\n        mesh.userData.isBase = true;\n        group.add(mesh);\n\n        //if assets is foreground, add to foreground group\n        if (id === \"foreground\") {\n          groupForeground.add(mesh);\n        }\n\n        if (id === \"sideLeft\") {\n          groupLeftSide.add(mesh);\n        }\n        if (id === \"sideRight\") {\n          groupRightSide.add(mesh);\n        }\n\n        if (id === \"background\") {\n          groupBackground.add(mesh);\n        }\n\n        //userData size\n        mesh.userData.size = {\n          format: texObj.width > texObj.height ? \"paysage\" : \"portrait\",\n          ratio: texObj.width > texObj.height ? texObj.height / texObj.width : texObj.width / texObj.height\n        };\n      }\n    });\n\n    // Load new objects \n    const newAssets = ['record', 'typewriter', 'partitions', 'carnet', 'poster', 'livre', 'violon', 'box']; // Add your new asset names here\n    const newMeshPositions = [\n      { x: -1.34, y: 0.05, z: -0.9999 },\n      { x: 2.6, y: 0.237, z: -0.9999 },    // 30% to the right\n      { x: 0.11, y: 0.068, z: -0.9999 },\n      { x: -0.29, y: -0.02, z: -1.9999 },\n      { x: 1.6, y: 1.02, z: -1.9999 },\n      { x: 0.016, y: 1.04, z: -1.9999 },\n      { x: 3.85, y: 1.35, z: -4.9999 },\n      { x: -2.02, y: -0.82, z: -0.9999 },\n    ];\n    const bgColors = [\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n      '253, 246, 250',\n    ]\n\n    //objects\n    newAssets.forEach((id, index) => {\n      const texObj = find(texturesItem, t => t.id === id);\n      if (texObj) {\n        // Load both main and glow textures\n        const mainTexture = loaderStore.getTexture(texObj.id);\n        const glowTexture = loaderStore.getTexture(`${texObj.id}_glow`);\n\n        mainTexture.colorSpace = SRGBColorSpace;\n        glowTexture.colorSpace = SRGBColorSpace;\n\n        // Create ShaderMaterial using both textures\n        const material = new ShaderMaterial({\n          uniforms: {\n            uTexture1: { value: mainTexture },\n            uTexture2: { value: glowTexture },\n            uHover: { value: 0.0 }, // Default hover value\n            uOpacity: { value: 0.0 }, // Default opacity\n          },\n          vertexShader: `\n            varying vec2 vUv;\n            void main() {\n              vUv = uv;\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n          `,\n          fragmentShader: `\n          uniform sampler2D uTexture1;\n          uniform sampler2D uTexture2;\n          uniform float uHover; // Uniform for hover effect\n          uniform float uOpacity; // global opacity\n          varying vec2 vUv;\n\n          void main() {\n            vec4 tex1 = texture2D(uTexture1, vUv);\n            vec4 tex2 = texture2D(uTexture2, vUv);\n            vec4 glow = vec4(tex2.rgb, tex2.a * uHover); // Apply hover value to the glow texture\n\n            // Apply gamma correction\n            vec4 correctedTex1 = pow(tex1, vec4(2.2));\n            vec4 correctedGlow = pow(glow, vec4(2.2));\n\n            gl_FragColor = correctedTex1 + correctedGlow; // Overlay the glow texture on top of the base texture\n            gl_FragColor = pow(gl_FragColor, vec4(1.0 / 2.2)); // Apply inverse gamma correction\n            gl_FragColor.a *= uOpacity; // Apply global opacity\n          }\n        `,\n          transparent: true, // Allow transparency if needed\n        });\n        // Create the mesh and assign material\n        const mesh = new Mesh(commonGeometry, material);\n        mesh.userData.position_ref = newMeshPositions[index];\n        mesh.name = texObj.id;\n        mesh.userData.bgColor = bgColors[index];\n        mesh.userData.scale = texObj.scale;\n\n        // Add the mesh to the appropriate group\n        if (id === \"box\" || id === \"record\" || id === \"partitions\" || id === \"typewriter\") {\n          groupForeground.add(mesh);\n        }\n        if (id === \"poster\" || id === \"carnet\") {\n          groupLeftSide.add(mesh);\n        }\n        if (id === \"livre\") {\n          groupRightSide.add(mesh);\n        }\n        if (id === \"violon\") {\n          groupBackground.add(mesh);\n        }\n        // Set userData size\n        mesh.userData.size = {\n          format: texObj.width > texObj.height ? \"paysage\" : \"portrait\",\n          ratio: texObj.width > texObj.height ? texObj.height / texObj.width : texObj.width / texObj.height,\n        };\n        // Animate appearance sequentially using GSAP\n        // Sequential animation with staggered delay\n        gsap.to(mesh.material.uniforms.uOpacity, { value: 1.0, duration: 2, ease:\"power4.out\", delay:2 + (index * .15) });\n        this.resize();\n      }\n    });\n\n  }\n\n  addEvents() {\n    mainWebGLRenderer?.domElement.addEventListener(\"click\", this.handlers.click);\n    mainWebGLRenderer?.domElement.addEventListener(\"mousemove\", this.handlers.move);\n    mainWebGLRenderer?.domElement.addEventListener(\"pointerdown\", this.handlers.start);\n    mainWebGLRenderer?.domElement.addEventListener(\"pointermove\", this.handlers.tmove);\n    mainWebGLRenderer?.domElement.addEventListener(\"pointerup\", this.handlers.end);\n  }\n\n  removeEvents() {\n    mainWebGLRenderer?.domElement.removeEventListener(\"click\", this.handlers.click);\n    mainWebGLRenderer?.domElement.removeEventListener(\"mousemove\", this.handlers.move);\n    mainWebGLRenderer?.domElement.removeEventListener(\"pointerdown\", this.handlers.start);\n    mainWebGLRenderer?.domElement.removeEventListener(\"pointermove\", this.handlers.tmove);\n    mainWebGLRenderer?.domElement.removeEventListener(\"pointerup\", this.handlers.end);\n  }\n\n  resizeGroup(group: Group) {\n    each(group.children, (child) => {\n      const defaultScale = child.userData.isBase ? this.sceneSize.height * child.userData.scale : child.userData.scale;\n\n      // Adjust the scale based on the new width\n      if (child.userData.size.format === 'paysage') {\n        child.scale.set(defaultScale, defaultScale * child.userData.size.ratio, 1);\n      } else {\n        child.scale.set(defaultScale * child.userData.size.ratio, defaultScale, 1);\n      }\n\n      // Set the position based on child id\n      if (child.userData.isBase) {\n\n        let posX = (this.sceneSize.width * child.userData.position_ref.x) + (child.scale.x * child.userData.position_ref.scx);\n\n        if (child.name === \"sideRight\") {\n          posX = Math.max(5, posX);\n        }\n\n        if (child.name === \"sideLeft\") {\n          posX = Math.min(-5, posX);\n        }\n\n        child.position.set(\n          posX,\n          this.sceneSize.height * child.userData.position_ref.y + (child.scale.y * child.userData.position_ref.scy),\n          child.userData.position_ref.z\n        );\n      } else {\n        // Set the position based on position_ref for other objects\n        const position = child.userData.position_ref;\n        child.position.set(group.children[0].position.x + position.x, group.children[0].position.y + position.y, position.z);\n      }\n\n      child.userData.position = child.position.clone();\n    });\n  }\n\n  // Resize is called by default (by the plugin) when the scene is created\n  resize() {\n    super.resize();\n\n    // If no children in the scene, let's build it\n    if (!this.scene.children.length) {\n      this.build();\n      this.addEvents();\n      if(appStore.introSeen) this.resetUserActivity();\n    } else {\n      const sideLeftGroup = this.scene.getObjectByName(\"leftSideGroup\") as Group;\n      const sideRightGroup = this.scene.getObjectByName(\"rightSideGroup\") as Group;\n      const foregroundGroup = this.scene.getObjectByName(\"foregroundGroup\") as Group;\n      const groupBackground = this.scene.getObjectByName(\"backgroundGroup\") as Group;\n\n      const groups = [sideLeftGroup, sideRightGroup, foregroundGroup, groupBackground];\n      each(groups, (group) => {\n        this.resizeGroup(group);\n      });\n    }\n  }\n\n\n  render(params: WebGLRenderParams) {\n    super.render(params);\n\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\") as Group;\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\") as Group;\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\") as Group;\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\") as Group;\n\n    //update mouse offset if the scene is too small\n    const sceneRatio = this.sceneSize.width / this.sceneSize.height;\n\n    this.mouseOffset.x = sceneRatio < 16 / 10 ? 140 : 20;\n\n    const speed = 0.5;\n    const offsetX = !this.mouse.x ? 0 : this.mouse.x / (this.sceneSize.width / this.mouseOffset.x);\n    const maxYOffset = 0.2; // Adjust this value based on your preference\n\n\n    let offsetY = this.mouse.y / (this.sceneSize.height / this.mouseOffset.y);\n    offsetY = clamp(offsetY, -maxYOffset * 2, maxYOffset);\n\n    const needsToBlink = !this.isUserActive;\n\n    // intersection\n    let isIntersecting: boolean = false;\n\n    // Convert this.mouse from Point to Vector2\n    const mousePosition = new Vector2(this.mouse.x, this.mouse.y);\n\n    // Use Raycaster for hover detection\n    this.raycaster.setFromCamera(mousePosition, this.camera);\n\n    if (groupBackground && groupBackground.children.length > 0) {\n\n      // Calculate the new position for the foreground with the mouse offset\n      const foregroundOffsetX = -(offsetX * 0.01);\n      const foregroundOffsetY = -(offsetY * 0.3);\n\n      // Damp the foreground group as a group\n      if (!this.touchTimers.tap) {\n        damp3(groupBackground.position, [\n          groupBackground.userData.position.x + foregroundOffsetX,\n          groupBackground.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"violon\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = groupBackground.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink ? 1.0 : 0.0);\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          // Interpolate the hoverValue gradually\n          damp(mesh.userData, 'hoverValue', targetValue, 0.5, params.delta);\n          // mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n          // Apply the updated hoverValue to the shader uniform\n          material.uniforms.uHover.value = mesh.userData.hoverValue;\n        }\n      });\n    }\n\n    if (groupForeground && groupForeground.children.length > 0) {\n\n      // Calculate the new position for the foreground with the mouse offset\n      const foregroundOffsetX = -(offsetX * 0.1);\n      const foregroundOffsetY = -offsetY;\n\n\n      // Damp the foreground group as a group\n      if (!this.touchTimers.tap) {\n        damp3(groupForeground.position, [\n          groupForeground.userData.position.x + foregroundOffsetX,\n          groupForeground.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"box\", \"record\", \"typewriter\", \"partitions\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = groupForeground.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          // Interpolate the hoverValue gradually\n          // mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n          damp(mesh.userData, 'hoverValue', targetValue, 0.5, params.delta);\n\n          // Apply the updated hoverValue to the shader uniform\n          material.uniforms.uHover.value = mesh.userData.hoverValue;\n        }\n      });\n    }\n\n    if (leftSideGroup && leftSideGroup.children.length > 0) {\n\n      const foregroundOffsetX = -(offsetX * 0.05);\n      const foregroundOffsetY = -offsetY * 0.7\n\n      // Damp the foreground group as a group\n      if (!this.touchTimers.tap) {\n        damp3(leftSideGroup.position, [\n          leftSideGroup.userData.position.x + foregroundOffsetX,\n          leftSideGroup.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"poster\", \"carnet\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = leftSideGroup.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          // Interpolate the hoverValue gradually\n          damp(mesh.userData, 'hoverValue', targetValue, 0.5, params.delta);\n          // mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n          // Apply the updated hoverValue to the shader uniform\n          material.uniforms.uHover.value = mesh.userData.hoverValue;\n        }\n      });\n    }\n\n    if (rightSideGroup && rightSideGroup.children.length > 0) {\n\n      const foregroundOffsetX = -(offsetX * 0.05);\n      const foregroundOffsetY = -offsetY * 0.7;\n\n      // Damp the foreground group as a group\n      if (!this.touchTimers.tap) {\n        damp3(rightSideGroup.position, [\n          rightSideGroup.userData.position.x + foregroundOffsetX,\n          rightSideGroup.userData.position.y + foregroundOffsetY,\n          0\n        ], speed, params.delta);\n      }\n\n      // Handle multiple objects in the foreground group\n      const targetMeshes = [\"livre\"]; // Add more names as needed\n      targetMeshes.forEach((name) => {\n        const mesh = rightSideGroup.getObjectByName(name) as Mesh;\n        if (mesh) {\n          const material = mesh.material as ShaderMaterial;\n\n          const intersects = this.raycaster.intersectObject(mesh);\n\n          // Determine target hover value (1.0 for hover, 0.0 otherwise)\n          const targetValue = (intersects.length > 0 || needsToBlink) ? 1.0 : 0.0;\n          if (intersects.length > 0 && !this.touchActive) isIntersecting = true;\n\n          // Smoothly interpolate hoverValue toward targetValue\n          if (!(\"hoverValue\" in mesh.userData)) {\n            mesh.userData.hoverValue = 0.0; // Initialize hoverValue if not present\n          }\n\n          // Interpolate the hoverValue gradually\n          damp(mesh.userData, 'hoverValue', targetValue, 0.5, params.delta);\n          // mesh.userData.hoverValue += (targetValue - mesh.userData.hoverValue) * 0.1;\n\n          // Apply the updated hoverValue to the shader uniform\n          material.uniforms.uHover.value = mesh.userData.hoverValue;\n        }\n      });\n    }\n\n    if(isIntersecting && this.ready) {\n      this.stopUserActivity();\n    }\n\n    document.body.style.cursor = isIntersecting ? \"pointer\" : \"default\";\n  }\n\n  dispose() {\n    // glScene.dispose()\n    // dispose every geometry and material for every Mesh children\n    super.dispose();\n\n    this.removeEvents();\n    document.body.style.cursor = \"default\";\n  }\n  // Get The Real Mouse Position with the offset position to the top left point\n  getMousePosition(evt: MouseEvent | TouchEvent | PointerEvent) {\n    const el = evt.currentTarget as HTMLElement;\n    const bounds = el.getBoundingClientRect();\n\n    let x = 0,\n      y = 0;\n\n    if (evt instanceof MouseEvent || evt instanceof PointerEvent) {\n      x = evt.clientX - bounds.left;\n      y = evt.clientY - bounds.top;\n    } else if (evt instanceof TouchEvent && evt.touches?.length > 0) {\n      x = evt.touches[0].clientX - bounds.left;\n      y = evt.touches[0].clientY - bounds.top;\n    }\n\n    this.mouse.x = (x / mainWebGLRenderer!.domElement.offsetWidth) * 2 - 1;\n    this.mouse.y = -(y / mainWebGLRenderer!.domElement.offsetHeight) * 2 + 1;\n  }\n\n  onMouseMove(e: MouseEvent): void {\n    this.getMousePosition(e);\n  }\n\n  // Handle touch start\n  handleTouchStart(e: PointerEvent) {\n    if (!interfaceStore.hasTouch) return;\n\n    this.touchActive = true;\n\n    e.preventDefault();\n    this.getMousePosition(e);\n\n    this.touchTimers.start = Date.now();\n  }\n\n  onTouchEnd(): void {\n    if (!interfaceStore.hasTouch) return;\n\n    this.touchActive = false;\n    this.touchTimers.end = Date.now();\n    //tap\n    const clickDelay = (this.touchTimers.end - this.touchTimers.start);\n    if (clickDelay < 250) {\n      this.touchTimers.tap = true;\n      this.handleIntersections();\n    }\n  }\n\n  onTouchMove(e: PointerEvent): void {\n    if (!interfaceStore.hasTouch) return;\n\n    if (!this.touchActive) return;\n\n    this.stopUserActivity();\n    this.getMousePosition(e);\n  }\n\n  handleClick(e: MouseEvent) {\n    if (interfaceStore.hasTouch) return;\n\n    // Normalize mouse coordinates\n    this.getMousePosition(e);\n\n    // Trigger the raycasting and handle intersections\n    this.handleIntersections();\n  }\n\n\n  handleIntersections() {\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n    const newAssets = ['record', 'typewriter', 'partitions', 'carnet', 'poster', 'livre', 'violon', 'box'];\n\n    if (this.disableClick) return;\n    let intersects;\n\n    // Get only the meshes in newAssets from the relevant groups\n    if (leftSideGroup && rightSideGroup && groupForeground && groupBackground) {\n      const meshesToCheck = [\n        ...newAssets.map((id) => {\n          const texObj = find(texturesItem, t => t.id === id);\n          let mesh = null;\n          if (texObj) {\n            mesh = leftSideGroup.getObjectByName(texObj.id)\n              || rightSideGroup.getObjectByName(texObj.id)\n              || groupBackground.getObjectByName(texObj.id)\n              || groupForeground.getObjectByName(texObj.id);\n          }\n          return mesh && mesh instanceof Mesh && mesh.material instanceof ShaderMaterial ? mesh : null;\n        })\n      ]\n        .filter((mesh): mesh is Mesh => mesh !== null); // This ensures that we only keep valid Mesh objects\n\n\n      if (meshesToCheck.length > 0) {\n        intersects = this.raycaster.intersectObjects(meshesToCheck);\n      }\n    }\n\n    if (intersects && intersects.length > 0) {\n      const clickedObject = intersects[0].object;\n\n      // Trigger fade-out effect and URL redirect\n      this.fadeOutAndRedirect(clickedObject);\n    }\n    else {\n      this.touchTimers.tap = false;\n    }\n  }\n\n  fadeOutAndRedirect(clickedObject: Object3D<Object3DEventMap>) {\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n\n    appStore.disableApp(true);\n    this.disableClick = true;\n\n    if (leftSideGroup && rightSideGroup && groupForeground && groupBackground) {\n      // Get all meshes from all groups for the fade effect\n      const allMeshes = [\n        ...leftSideGroup.children,\n        ...rightSideGroup.children,\n        ...groupForeground.children,\n        ...groupBackground.children\n      ]\n        .filter(child => child instanceof Mesh && child.material instanceof ShaderMaterial);  // Filter only ShaderMaterial meshes\n\n      // Fade out all meshes first, then the clicked one\n      gsap.timeline()\n        .to(\n          allMeshes.map((mesh) => {\n            // Ensure the object is a Mesh before accessing material\n            if (mesh instanceof Mesh && mesh.material instanceof ShaderMaterial) {\n              return mesh.material.uniforms.uOpacity;\n            }\n            return null; // Return null if it's not a ShaderMaterial\n          }).filter((uniform) => uniform !== null), // Filter out null values\n          {\n            value: 0, // Fade out all items\n            duration: 1,\n            stagger: 0.1, // Stagger the fade out effect for sequential disappearing\n            ease: \"power2.out\"\n          })\n        .to(\n          clickedObject instanceof Mesh && clickedObject.material instanceof ShaderMaterial\n            ? (clickedObject.material as ShaderMaterial).uniforms.uOpacity\n            : null,\n          {\n            value: 0, // Fade out the clicked object last\n            duration: 1,\n            ease: \"power2.out\"\n          }\n        )\n        .add(() => {\n          // After fade-out animation, navigate to the specific URL for clicked object\n          emitter.emit(EVENTS.CLICK_THEME, { name: clickedObject.name, bgColor: clickedObject.userData.bgColor });\n        }, 1);\n    }\n  }\n\n  exitFromMainHeader(url: string) {\n    let myMesh: O<Object3D<Object3DEventMap>> = undefined;\n\n    const leftSideGroup = this.scene.getObjectByName(\"leftSideGroup\");\n    const rightSideGroup = this.scene.getObjectByName(\"rightSideGroup\");\n    const groupForeground = this.scene.getObjectByName(\"foregroundGroup\");\n    const groupBackground = this.scene.getObjectByName(\"backgroundGroup\");\n\n    switch (url) {\n      case \"/yannick-nezet-seguin/\":\n        myMesh = groupForeground?.getObjectByName(\"partitions\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/charles-dutoit/\":\n        myMesh = rightSideGroup?.getObjectByName(\"livre\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/universite-de-montreal/\":\n        myMesh = leftSideGroup?.getObjectByName(\"carnet\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/metier-role-de-critique/\":\n        myMesh = groupForeground?.getObjectByName(\"typewriter\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/les-raretes/\":\n        myMesh = groupForeground?.getObjectByName(\"box\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/festival-de-lanaudiere/\":\n        myMesh = groupBackground?.getObjectByName(\"violon\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/oeuvres-preferees/\":\n        myMesh = groupForeground?.getObjectByName(\"record\") as Object3D<Object3DEventMap>;\n        break;\n\n      case \"/maria-callas/\":\n        myMesh = leftSideGroup?.getObjectByName(\"poster\") as Object3D<Object3DEventMap>;\n        break;\n    }\n\n    if (myMesh) {\n      this.fadeOutAndRedirect(myMesh);\n    }\n  }\n\n  setReady() {\n    setTimeout( () => {\n      this.resetUserActivity();\n      this.ready = true;\n\n      //we have seen the intro\n      appStore.setIntroSeen(true);\n    }, 500);\n  }\n}\n\n"],"names":["baseClamp","number","lower","upper","_baseClamp","require$$0","toNumber","require$$1","clamp","clamp_1","textures","commonGeometry","PlaneGeometry","commonMaterial","MeshBasicMaterial","LibraryScene","WebGLScene","options","__publicField","Raycaster","appStore","group","Group","groupForeground","groupLeftSide","groupRightSide","groupBackground","groupObject","assets","mesh_positions","id","index","texObj","find","t","data","loaderStore","SRGBColorSpace","material","mesh","Mesh","newAssets","newMeshPositions","bgColors","texturesItem","mainTexture","glowTexture","ShaderMaterial","gsap","mainWebGLRenderer","each","defaultScale","child","posX","position","sideLeftGroup","sideRightGroup","foregroundGroup","params","leftSideGroup","rightSideGroup","sceneRatio","offsetX","offsetY","maxYOffset","needsToBlink","isIntersecting","mousePosition","Vector2","foregroundOffsetX","foregroundOffsetY","damp3","speed","name","intersects","targetValue","damp"],"mappings":"ieASA,SAASA,EAAUC,EAAQC,EAAOC,EAAO,CACvC,OAAIF,IAAWA,IACTE,IAAU,SACZF,EAASA,GAAUE,EAAQF,EAASE,GAElCD,IAAU,SACZD,EAASA,GAAUC,EAAQD,EAASC,IAGjCD,CACT,CAEA,IAAAG,EAAiBJ,ECrBbA,EAAYK,EACZC,EAAWC,EAqBf,SAASC,GAAMP,EAAQC,EAAOC,EAAO,CACnC,OAAIA,IAAU,SACZA,EAAQD,EACRA,EAAQ,QAENC,IAAU,SACZA,EAAQG,EAASH,CAAK,EACtBA,EAAQA,IAAUA,EAAQA,EAAQ,GAEhCD,IAAU,SACZA,EAAQI,EAASJ,CAAK,EACtBA,EAAQA,IAAUA,EAAQA,EAAQ,GAE7BF,EAAUM,EAASL,CAAM,EAAGC,EAAOC,CAAK,CACjD,CAEA,IAAAM,GAAiBD,kBCtCXE,GAAW,CACf,CACE,GAAI,aACJ,MAAO,KACP,OAAQ,IACR,MAAO,IACT,EACA,CACE,GAAI,WACJ,MAAO,KACP,OAAQ,KACR,MAAO,IACT,EACA,CACE,GAAI,YACJ,MAAO,KACP,OAAQ,KACR,MAAO,IACT,EACA,CACE,GAAI,aACJ,MAAO,KACP,OAAQ,KACR,MAAO,IAAA,CAEX,ECzBMA,EAAW,CACf,CACE,GAAI,MACJ,MAAO,IACP,OAAQ,IACR,MAAO,IACT,EACA,CACE,GAAI,SACJ,MAAO,IACP,OAAQ,IACR,MAAO,GACT,EACA,CACE,GAAI,aACJ,MAAO,IACP,OAAQ,IACR,MAAO,CACT,EACA,CACE,GAAI,aACJ,MAAO,IACP,OAAQ,IACR,MAAO,IACT,EACA,CACE,GAAI,SACJ,MAAO,IACP,OAAQ,IACR,MAAO,EACT,EACA,CACE,GAAI,SACJ,MAAO,IACP,OAAQ,IACR,MAAO,EACT,EACA,CACE,GAAI,QACJ,MAAO,IACP,OAAQ,IACR,MAAO,GACT,EACA,CACE,GAAI,SACJ,MAAO,IACP,OAAQ,IACR,MAAO,GAAA,CAGX,EClCAC,EAA2B,IAAAC,EAAA,EAAA,CAAA,EAGjBC,GAAqC,IAAAC,EAAA,CAAA,cAEe,CAAA,QAE5DC,WAAAC,CAAA,CA6BmB,YACRC,EAAgB,CACvB,MAAAA,CAAA,EA9BJC,EAAA,iBAAA,IAAAC,GACAD,EAAA,oBAA4B,IAC5BA,EAAA,2BAAA,MACAA,EAAA,uBACAA,EAAA,mBACAA,EAAA,iBACAA,EAAA,aAAgB,CACF,EAAA,EACL,EAAA,CACF,GAAAA,EAAA,mBACA,IACPA,EAAA,oBAAA,IAAAA,EAAA,oBAIE,EAAA,GAEA,EAAK,EAAW,GAEkBA,EAAA,4BAEFA,EAAA,aACvB,IAETA,EAAA,mBAAkB,CAAA,MACX,EAAA,IACT,EAAA,IAAA,EAAA,GAKI,YAAA,SAAoB,CACtB,MAAA,KAAA,YAAA,KAAA,IAAA,EACF,KAAA,KAAA,YAAA,KAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,KAAA,IAAA,EAGoB,IAAA,KAAA,WAAA,KAAA,IAAA,EAElB,MAAoB,KAAA,YAAA,KAAA,IAAA,CACpB,EAEA,KAAA,WAAuB,EAElB,IAAA,CAIL,kBACc,CAEZ,KACY,iBACV,KAAoB,eAAA,KAAA,EAE1B,kBAAA,GAI0B,oBAIlB,CACN,KAEA,aAAA,GAEM,KAAA,mBACNE,CAAAA,EAEc,YAER,KAAA,kCACN,GAEA,YAAA,EAGA,MAAA,GAIM,CAAA,EAAA,IAAA,IAAA,CACN,KAAmB,aAAA,EACnB,EAAA,CAAA,EAAA,SAEK,KAAA,aAAA,EACA,EAAA,CAAA,EAEA,CAIC,OAAA,CACN,MAAAC,EAAuB,IAAAC,EAErBD,EAAA,KAAA,YACKA,EAAA,SAAA,EAAA,EAAqC,MAAAE,EAAA,IAAAD,EAE5CC,EAAA,KAAA,kBAGEA,EAAA,kBAAmCA,EAAA,SAAA,MAAA,EACnC,MAAAC,EAAY,IAAAF,EAEVE,EAAA,KAAkB,gBAElBA,EAAA,kBAAeA,EAAA,SAAA,MAAA,EACf,MAAAC,EAAmB,IAAAH,EACnBG,OAAsB,iBAEtBA,EAAa,SAAA,SAAAA,EAAA,SAAA,MAAA,EACR,MAAAC,EAAwB,IAAAJ,EAC7BI,EAAmB,KAAA,kBACdA,EAAwB,SAAA,SAAAA,EAAA,SAAA,MAAA,EAC7B,MAAAC,EAAuB,IAAAL,EACvBK,OAAc,cAKdA,EAAA,SAAA,EAAA,EAEA,KAAA,MAAuB,IAAAN,CAAA,EACrB,KAAA,MAAA,IAAAM,GACF,KAAA,MAAA,IAAAD,CAAA,EAAA,KAAA,MAAA,IAAAF,CAAA,EACA,KAAA,WAAwB,EAAA,KAAA,MAAA,IAAAD,CAAA,EACtB,MAAAK,EAAA,CAAA,aAAuB,WAAA,YAAA,YAAA,EACzBC,EAAA,CAAA,CAGE,EAAA,EACF,EAAA,EAGA,EAAA,GAAqB,IAAA,EAEnB,IAAA,GACF,EAAA,CACF,EAAA,GACD,EAAA,EAGK,EAAA,GAEF,IAAA,IACG,IAAA,GAA0B,EAE7B,CACA,EAAA,EAGA,EAAA,EACJ,EAAA,GACA,IAAA,KAEE,IAAA,GACA,EAEA,CACA,EAAA,EACA,EAAA,GAEF,EAAA,GAGU,IAAA,EACR,IAAA,IAIE,CAAA,EAAgCD,EAEhC,QAAA,CAAAE,EAAAC,IAAyB,CACzB,MAAAC,EAAyBC,EAAAvB,GAAAwB,GAAAA,EAAA,KAAAJ,CAAA,EAGnB,GAAAE,EAAA,CAA8B,MAAAG,EAAAC,EAAA,WAAAJ,EAAA,EAAA,EAEhCG,EAAA,WAAAE,EAEqB,MAAAC,EAAAzB,GAAA,MAAA,EACrByB,EAAY,IAAAH,EAAWG,EAAA,QAAA,EACzBA,EAAA,WAAA,GAAA,MAAAC,EAAA,IAAAC,EAAA7B,EAAA2B,CAAA,EAAAC,EACc,SAAA,aAAAV,EAAAE,CAAA,EAAAQ,EAAA,KAAAP,EAAA,GAAAO,EAAA,SAAA,MAAAP,EAAA,MAAAO,EAAA,SAAA,OAAA,GAAAlB,EAAA,IAAAkB,CAAA,EAAAT,IAAA,cAAAP,EAAA,IAAAgB,CAAA,EAOET,IAAA,YAAAN,EAAA,IAAAe,CAAA,EAAAT,IAAA,aAAAL,EAAA,IAAAc,CAAA,EAAAT,IAAA,cAAAJ,EAAA,IAAAa,CAAA,EAAAA,EAAA,SAAA,KAAA,CAAA,SAAA,MAAAP,EAAA,OAAA,UAAA,WAAA,MAAAA,EAAA,MAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAA,CAAA,CAAA,CAAA,EAAA,MAAAS,EAAA,CAAA,SAAA,aAAA,aAAA,SAAA,SAAA,QAAA,SAAA,KAAA,EAsBjBC,EAAA,CAAA,CAAA,EAAA,MAGI,EAAA,IACL,EAAA,MAAmB,EACd,CAAmB,EAAA,IACnB,EAAA,KAAwB,EAAA,MAG7B,EACE,CAAA,EAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,CAAA,EAAA,KAAA,EAAA,KAOF,EAAA,OAAA,EAAA,CAAA,EAAA,IAAA,EAAA,KAAA,EAAA,OAAA,EAAA,CAAA,EAAA,KAAA,EAAA,KAAA,EAAA,OAAA,EAAA,CAAA,EAAA,KAAA,EAAA,KAAA,EAAA,OAAA,EAAA,CAAA,EAAA,MAAA,EAAA,KAAA,EAAA,MAAA,CAAA,EAAAC,EAAA,CAAA,gBAAA,gBAAA,gBAAA,gBAAA,gBAAA,gBAAA,gBAAA,eAAA,EAAAF,EAAA,QAAA,CAAAX,EAAAC,IAAA,CAAA,MA2BeC,EAAAC,EAAAW,EAAAV,GAAAA,EAAA,KAAAJ,CAAA,EAAA,GAAAE,EAAA,CACnB,MAAAa,EAAAT,EAAA,WAAAJ,EAAA,EAAA,EAEAc,EAA8BV,EAAA,WAAoB,GAAAJ,EAAA,EAAA,OAAA,EAClDa,EAAA,WAA8BR,EAChCS,EAAA,WAAAT,UAE0B,IAAAU,EAAA,CACnB,SAAA,CAKK,UAAwB,CACzB,MAAAF,CACC,EACR,UAAA,CAGI,MAAAC,CAEF,EAEI,OAA4B,CACvB,MAAA,CACT,EAGS,SAAA,CACT,MAAA,CAGE,CAEA,EAKF;;;;;;YAaF,eAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAyCT,YAA0B,EAQP,CAAA,EAOXP,QAAiB5B,EAAA2B,CAAA,0BACOI,EAAAX,CAAA,EAC9BQ,EAAA,KAAAP,EAAA,GAEAO,EAAA,SAAA,QAAAI,EAAAZ,CAAA,EACFQ,EAAA,SAAA,MAAAP,EAAA,OACFF,IAAA,OAAAA,IAAA,UAAAA,IAAA,cAAAA,IAAA,eAIMP,EAAwB,IAAAgB,CAAA,GAEtBT,IAAA,UAAAA,IAAA,WAEJN,EAAA,KAAsB,EAKtBM,IAAA,SAIIL,EAAkB,IAAAc,CAAgB,EAEtCT,IAAA,UAAAJ,EAAA,IAAAa,CAAA,EAQFA,EACD,SAAA,KAAA,CAMK,OAAAP,EAAA,MAAgCA,EAAA,OAAA,UAAA,WACtC,wDAII,EACFgB,EAAA,GAAAT,oBAAgC,SAAA,CAC9B,MAAA,EACA,SAAyB,EACzB,KAAA,aACF,MAAsB,EAAAR,EAAA,GACxB,CAAA,EAIa,KAAA,OAAA,CACL,CACN,CAAA,CAAU,CAGR,WAAA,gBAGAkB,EAAAA,IAAAA,MAAAA,EAAA,WAAA,iBAAA,QAAA,KAAA,SAAA,sBAK6B,WAAA,iBAAA,YAAA,KAAA,SAAA,OAC7BA,EAAAA,IAAAA,MAAAA,EAAA,WAAA,iBAAA,cAAA,KAAA,SAAA,QAOAA,EAAAA,IAAAA,MAAAA,EAAkB,WAAe,iBAAA,cAAc,KAAA,SAAA,QACjDA,EAAAA,IAAAA,MAAAA,EAAA,WAAA,iBAAA,YAAA,KAAA,SAAA,IAAA,CAEJ,cAAA,gBAKQA,EAAAA,IAAAA,MAAAA,EAAA,WAA+B,oBAAA,QAAA,KAAA,SAAA,QAInCA,EAAAA,IAAAA,MAAAA,aAA8B,oBAAA,YAAA,KAAA,SAAA,OAE5BA,EAAAA,IAAAA,MAAAA,EAAA,WAAA,oBAAA,cAAA,KAAA,SAAA,QACAA,EAAAA,IAAAA,MAAAA,EAAA,WAAA,oBAAA,cAAA,KAAA,iBACFA,EAAAA,IAAAA,MAAAA,EAAU,WAAA,oBAAA,YAAA,KAAA,SAAA,IAKC,CACL,YAAA5B,EAAA,CAEJ6B,EAAA7B,EAAA,YAAsB,CAMtB,MAAwB8B,EAAAC,EAAA,SAAA,OAAA,KAAA,UAAA,OAAAA,EAAA,SAAA,MAAAA,EAAA,SAAA,MA0BxB,GArBAA,EAAA,SAAA,KAAA,SAAA,UAQFA,EAAA,MAAA,IAAAD,EAAAA,EAAAC,EAAA,SAAA,KAAA,MAAA,CAAA,EAOIA,EAAA,MAAA,IAAAD,EAA+BC,EAAA,SAAA,KAAA,MAAAD,EAAA,CAAA,EAMjCC,EAAA,SAAA,OAAwB,CACxB,IAAAC,iBAAA,MAAAD,EAAA,SAAA,aAAA,EAAAA,EAAA,MAAA,EAAAA,EAAA,SAAA,aAAA,IACFA,EAAA,OAAsB,cACxBC,EAAA,KAAA,IAAA,EAAAA,CAAA,GAIaD,EAAA,OAAkB,aACvBC,EAAA,KAAA,IAAA,GAAAA,CAAA,kBAQoBA,EAAA,KAAA,UAAA,OAAAD,EAAA,SAAA,aAAA,EAAAA,EAAA,MAAA,EAAAA,EAAA,SAAA,aAAA,IAAAA,EAAA,SAAA,aAAA,CAAA,CAGpB,KAAA,CACF,gCACFA,EAAA,aAAA/B,EAAA,SAAA,CAAA,EAAA,SAAA,EAAAiC,EAAA,EAAAjC,EAAA,SAAA,CAAA,EAAA,SAAA,EAAAiC,EAAA,EAAAA,EAAA,CAAA,CAOA,CAGNF,EAAA,SAAA,SAAAA,EAAA,SAAA,MAAA,CAEG,CAAA,CAIH,CAGQ,QAAA,CAUF,GAJG,MAAA,SAIH,CAAA,KAAA,MAAS,SAAA,OACT,KAAA,MAAA,EAEF,KAAA,UAAA,EAGAhC,EAAA,WAAA,KAAA,kBAAA,MAEuB,CAGjB,MAAAmC,EAAA,WAA4B,gBAAA,eAAA,EACtCC,OAAA,MAAA,gBAAA,gBAAA,EAM+BC,EAAA,KAAA,MAAA,gBAAA,iBAAA,EAC/B/B,EAAuB,KAAA,MAAA,gBAAA,iBAAA,EACzBwB,EAAA,CAAAK,EAAAC,EAAAC,EAAA/B,CAAA,EAAAL,GAAA,qBAIM,CAA0B,CAOzB,CACP,OAAAqC,EAAA,CAEmB,MAAA,OAAAA,CAAA,EACb,MAAAC,8CAEeC,EAAA,KAAA,MAAA,gBAAA,gBAAA,EAGbrC,EAA+B,KAAA,MAAA,gBAAA,iBAAuB,EAG1DG,EAAyB,KAAA,MAAA,gBAAA,iBAAA,EAC3BmC,OAAA,UAAA,qBAAA,wBAI8B,EAAAA,EAAA,GAAA,GAAA,IAAA,cAIRC,EAAA,KAAA,MAAA,EAAA,KAAA,MAAA,GAAA,KAAA,UAAA,MAAA,KAAA,YAAA,GAAA,IAKO,GAO/B,IAAAC,EAAA,KAAA,MAAA,GAAA,KAAA,UAAA,OAAA,KAAA,YAAA,GAGsBA,EAAAvD,GAAAuD,EAAA,CAAAC,EAAA,EAAAA,CAAA,EAAA,MACpBC,EAAA,CAAA,KAAA,aACA,IAAAC,EAAA,GAEA,MAAwBC,EAAA,IAAAC,EAAA,KAAW,MAAA,EAAA,KAAiC,MAAA,CAAA,EAIhE,kCADmB,KAAA,MAAA,EACnB1C,GAAAA,EAAA,SAAA,OAAA,EAAA,CAKG,MAAA2C,EAAsB,EAAAP,EAAA,KACvBQ,EAAoB,EAAAP,EAAA,IACpB,KAAA,YAAW,KACXQ,EAAA7C,EAAY,SAAA,CAAAA,EAAA,SAAA,SAAA,EAAA2C,EAAA3C,EAAA,SAAA,SAAA,EAAA4C,EAAA,CAAA,EAAAE,EAAAd,EAAA,KAAA,EAKZ,CAAA,QAAA,EACA,QAAAe,GAAA,CAMA,MAAAlC,EAAAb,kBAA0B+C,CAAA,EACf,GAAAlC,EAAA,CACf,MAAAD,EAAAC,EAAA,SACFmC,EAAA,KAAA,UAAA,gBAAAnC,CAAA,EAEIoC,EAAyBD,EAAA,OAAA,GAAAT,EAAA,EAAA,EAI3BS,SAAqC,GAAA,CAAA,KAAA,cAAAR,EAAA,IAIvC,eAAA3B,EAAA,WACFA,WAAA,WAAA,GAK0BqC,EAAArC,WAAW,aAAAoC,EAAA,GAAAjB,EAAA,KAAA,EAC7BpB,EAAA,SAAA,OAAA,MAAAC,EAAA,SAAA,UAKF,GAKmB,CACnB,2BAKF,MAAA8B,EAAA,EAAAP,EAAA,IAI0BQ,EAAA,CAAAP,EAEpB,KAAA,YAAA,KACOQ,EAAAhD,EAAA,SAAA,CAAAA,EAAA,SAAA,SAAA,EAAA8C,EAAA9C,EAAA,SAAA,SAAA,EAAA+C,EAAA,CAAA,EAAAE,EAAAd,EAAA,KAAA,SAGA,SAAA,aAAA,YAAA,EAAA,QAAAe,GAAA,CACP,MAAAlC,EAAAhB,EAAU,gBAAAkD,CAAA,EACV,GAAAlC,EAAA,CAAS,MAAAD,EAAAC,EAAA,SAAAmC,EAAA,KAAA,UAAA,gBAAAnC,CAAA,EAIXoC,oBAGAD,EAAA,OAAA,GAAA,CAAA,KAAA,cAAAR,EAAA,IACS,eAAA3B,EAAA,WAAAA,EAAA,SAAA,WAAA,GAGTqC,EAAArC,EAAA,SAAA,aAAAoC,EAAA,GAAAjB,EAAA,KAAA,EAKEpB,EAAA,SAAA,OAAA,MAAAC,EAAA,mBACR,CAI4C,CAAA,CAEtB,CAChB,GAAAoB,GAAAA,EAAA,SAAA,OAAA,EAAA,CAIN,MAAAU,EAAa,EAAAP,EAAA,KAKNQ,EAAA,CAAAP,EAAA,GACM,KAAA,YAAA,KACTQ,EAAAZ,EAAA,SAAA,CAAAA,EAAA,SAAA,SAAA,EAAAU,EAAAV,EAAA,SAAA,SAAA,EAAAW,EAAA,CAAA,EAAAE,EAAAd,EAAA,KAAA,YAIA,QAAA,EAEG,QAAAe,GAAA,CACM,MAAAlC,EAAAoB,EAAA,gBAAAc,CAAA,EACT,GAAAlC,EAEG,CACM,MAAAD,EAAAC,EAAA,SAGNmC,EAAA,KAAA,UAAA,gBAAAnC,CAAA,EAIAoC,EAAAD,EAAA,OAAA,GAAAT,EAAA,EAAA,EAEHS,EAAA,OAAA,GAAA,CAAA,KAAA,cAAAR,EAAA,IAEG,eAAA3B,EAAA,WACMA,EAAA,SAAA,WAAA,OAEb,SAAA,aAAAoC,EAAA,GAAAjB,EAAA,KAAA,EAEYpB,EAAA,SAAA,OAAA,MAAAC,EAAA,SAAA,UACV,CAEJ,CAAA,CAII,CACA,GAAAqB,GAAaA,EAAA,SAAA,OAAA,EAAA,CAGb,MAAAS,EAA0B,EAAAP,EAAA,OACtB,CAAAC,EAAA,GACR,KAAA,iBACFQ,EAAAX,WAAA,CAAAA,EAAA,SAAA,SAAA,EAAAS,EAAAT,EAAA,SAAA,SAAA,EAAAU,EAAA,CAAA,EAAAE,EAAAd,EAAA,KAAA","x_google_ignoreList":[0,1]}
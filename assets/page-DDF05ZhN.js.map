{"version":3,"file":"page-DDF05ZhN.js","sources":["../../src/vue/src/utils/flow/page.ts"],"sourcesContent":["/**\n * # FlowPage\n * > a custom lifecycle for our pages\n * \n * like simple flow but handle more stuff for page\n * - loading + app ready etc\n * - @TODO SEO metas\n * \n */\nimport scrollStore from 'components/SmoothScroll/store';\nimport cursorStore from 'components/UiKit/Cursor/store';\nimport { client, getEnv, IS_DEV, motion, server } from 'config';\nimport { keys, map, merge, zipObject } from 'lodash';\nimport ApiHelper from 'plugins/api';\n//  import storeLoader from 'components/ui/Loader/store';\nimport SEOStore from 'plugins/seo/store';\nimport appStore from 'plugins/store/app';\nimport { computed, ComputedRef, nextTick, onMounted, readonly, ref, Ref, unref, watch } from 'vue';\n\n\n\n/**\n  * STATES are incrmental values\n  * *onLoaded will be triggered even if current state higher like READY*\n  * (destroy states may be negative so super specific)\n*/\nexport const STATES = {\n  DEFAULT: 0,\n  LOADED: 1,\n  INIT: 2,\n  INIT_UI: 3,\n  READY: 4\n}\n\n\nexport interface FlowPageOptions<T extends Obj> {\n  data?: () => T\n  api?: {\n    url: string,\n    format?: (data: any) => any,\n    // load api only 1 time \n    cache?: boolean,\n    moc: boolean,\n    getMoc: (a?: string) => Promise<AsyncImportMoc | any>,\n  },\n  /** load your data\n   * will wait this loader, store data, then setState(LOADED)\n   * > HOOK: ON_INIT avaible aftre this complete\n  */\n  load?: (loadTwigData: boolean) => Promise<Obj>,\n  /** preload ui dependencies + wait onMounted\n   * triggered only if `motion`- start loading on setup but do not bloack maiin loading state\n   * > HOOK: ON_INIT_UI avaible after completion\n   * ui:{\n   *   gsap: ()=>import('gsap').then(m=>m.default)\n   * }import { unref } from 'vue';\n  */\n  ui?: {\n    [key: string]: () => Promise<any>\n  }\n  /**\n   * **MUST BE CALLED FOR PAGES** -  used to hide loader etc\n   * \n   * You may let this flow handle `autoSetReady`\n   * or call yourself `const {setReady} = useFlow()`\n   * - if motion, please initUi() and hide stuff before setReady()\n   * - else, call setReady right after onInit()\n  */\n  autoSetReady?: boolean\n  /** if true, setReady trigger appStore.setPageReady() */\n  isPage?: boolean\n  /** if true, log flow etc */\n  debug?: boolean | string\n}\n\nexport type FlowHookArgs = {\n  client: boolean, server: boolean, motion: boolean\n}\n// type FlowCallback = (arg0:{\n//   client:boolean, server:boolean, motion:boolean\n// })=>unknown\n\nexport interface FlowPage<T> {\n  /** \n   * ready to render CPN\n   * - actualy event before STATES.READY (when ui hidden)\n   * - true when INIT/INIT_UI\n  */\n  ready: ComputedRef<boolean>\n  loaded: ComputedRef<boolean>\n  readyToRender: ComputedRef<boolean>\n  state: Ref<number>\n  /** return api data - if response = {meta, data} then getData will return only the `data` node (without seo) */\n  getData: () => Ref<T>\n  /** return api data - if response = {meta, data} then getMeta will return only the `meta` node */\n  getMeta: () => Obj\n  /** return api data.seo - just because used only in html metas... */\n  getSEO: () => Obj\n  /** return api data.translations - for locale switcher + seo alternate */\n  getTranslation: () => Obj\n  /** once data ready and correct lifecicle hook - may call auto.\n   * > exept if declare autoSetReady=true **you must setReady yourself**\n  */\n  setReady: () => void,\n  /** just after loading stuff - before onInit */\n  onloaded: (next: (arg: FlowHookArgs & { data: T }) => unknown) => Promise<unknown>\n  /**\n   * data loaded - like a onMounted()\n   * - if server = right after loaded\n   * - if client = loaded + mounted\n  */\n  onInit: (next: (arg: FlowHookArgs & { data: T }) => unknown) => Promise<unknown>\n  /**\n   * init ui stuff (init + preload ui + moUnted)\n   * **only if motion**\n  */\n  onInitUi: (next: (arg: FlowHookArgs & { data: T } & { ui: Obj }) => unknown) => Promise<unknown>\n}\n\n\nexport function usePageFlow<T extends Obj>(opts: FlowPageOptions<T> = {}): FlowPage<T> {\n  const options = {\n    autoSetReady: true,\n    ...opts\n  }\n  function debug(...params: any[]) { // eslint-disable-line\n    if (!options.debug || !IS_DEV) return\n  }\n\n  const state = ref<number>(STATES.DEFAULT)\n  let uiVendors = {}\n\n  const _data = ref((options.data?.() ?? {}) as T) // store the response `meta` node (like no meta or data.data)\n  function getData() {\n    return readonly(_data) \n    // const ensured:unknown = readonly(_data) \n    // return ensured as Ref<T>\n  }\n\n  const _meta = ref<Obj>({}) // store the response `meta` node\n  function getMeta() {\n    return readonly(_meta.value) as Obj\n  }\n\n  // @todo define Obj type\n  const _seo = ref<Obj>({}) // store the response `seo` node\n  function getSEO() {\n    return readonly(_seo?.value || undefined) as Obj\n  }\n\n  // @todo define Obj type\n  const _translation = ref<any>() // store the response `translation` node\n  function getTranslation() {\n    return readonly(_translation?.value || undefined)\n  }\n\n  /**\n   * to be triggered once loading ready\n   * May wait some required states before\n   */\n  function setReady(ready = true) {\n    if (!ready) {\n      state.value = STATES.DEFAULT\n      return\n    }\n    if (state.value === STATES.READY) {\n      setTimeout(() => {\n        // trigger SEO update from data received\n        SEOStore.UPDATE(getSEO(), getTranslation());\n\n        appStore.setPageReady()\n        // storeLoader.setLoaded() // nop\n        scrollStore.refreshScroll();\n        scrollStore.scrollTop();\n\n        setTimeout(() => {\n          window.prerenderReady = true;\n        }, 500);\n      }, 500)\n      return\n    }\n    const requiredState = motion ? STATES.INIT_UI : STATES.INIT\n    debug('setReady -', { motion, state: state.value, requiredState });\n    waitForState(requiredState)\n      .then(() => {\n        // trigger SEO update from data received\n        SEOStore.UPDATE(getSEO(), getTranslation());\n\n        state.value = STATES.READY\n        appStore.setPageReady()\n        // storeLoader.setLoaded() // nop\n        scrollStore.refreshScroll()\n\n        setTimeout(() => {\n          window.prerenderReady = true;\n        }, 500);\n      })\n  }\n\n  function waitForState(stateToMatch: number) {\n    return new Promise(resolve => {\n      const unwatch = watch(state, (current) => {\n        debug('waitForState', current, stateToMatch);\n        if (current >= stateToMatch) {\n          setTimeout(() => {\n            resolve(true)\n            unwatch()\n          }, 14) // this setTimeout allow to setup all sub components before (if they use useFlow)\n        }\n      }, { immediate: true, flush: 'post' })\n    })\n  }\n\n\n  async function load() {\n    return new Promise(resolve => {\n      /* many way to fetch data - multiples caches strategies\n        if you are lost - poke a lead ðŸ˜˜ */\n\n      // function is 1st level because asume custom stuff (preload assets etc)\n      const isFunction  = typeof options.load === 'function'\n      if (isFunction)   return resolve(options.load!(!appStore.firstPageReady))\n      \n      // craft may inject 1st page data in window._PAGE\n      const isWindowPage= window.__PAGE && !appStore.firstPageReady && !getEnv('VITE_MOC_API') && !options.api?.moc;\n\n      if (isWindowPage) {\n        // if cache active, save this\n        if (options.api?.cache && options.api?.url ) {\n          if (!window.__CACHE) {\n            window.__CACHE = {}\n          }\n          window.__CACHE[options.api.url] = JSON.stringify(options.api?.format?.({ data: window.__PAGE }) ?? window.__PAGE)\n        }\n        return resolve(options.api?.format?.({ data: window.__PAGE }) ?? window.__PAGE)\n      } \n      \n      // cache system window variables.\n      const isInCache = options.api?.cache && options.api?.url && window.__CACHE && window.__CACHE[options.api.url] ;\n      if (isInCache && window.__CACHE && options.api?.url && window.__CACHE[options.api.url])    return resolve(JSON.parse(window.__CACHE[options.api.url] ))\n\n      // simply use api helper (mocable)\n      const isApiObject = options.api;\n      if (isApiObject) return resolve(ApiHelper.get(options.api!.url, {}, { showErrorMessage: false, ...options.api }))\n      \n      return resolve({})\n    })\n      .then((response?: any) => {\n        function mergeWithOptionsData(data: any) {\n          if (!options.data) return data\n          return merge({}, options.data(), data ?? {})\n        }\n        if (typeof response === 'object' && response) {\n          if (response.data) {\n            if (response.meta) _meta.value = response.meta\n            const { seo, translations, translation, ...page } = response.data\n            if (seo) _seo.value = seo\n            if (translations || translation) _translation.value = translations || translation\n            _data.value = mergeWithOptionsData(page)\n          } else {\n            const { seo, translations, translation } = response\n            if (seo) _seo.value = seo\n            if (translations || translation) _translation.value = translations || translation\n            _data.value = mergeWithOptionsData(response)\n          }\n        }\n\n        state.value = STATES.LOADED\n\n        // save cache api\n        if (options.api?.cache && options.api?.url) {\n          if (!window.__CACHE) {\n            window.__CACHE = {}\n          }\n          window.__CACHE[options.api.url] = JSON.stringify(response)\n        }\n\n        return response\n      })\n      // on error, with page flow sometimes this is reallll bad\n      .catch(() => {\n        // set as 404\n        appStore.setIs404();\n      })\n  }\n\n  async function preloadUi() {\n    return new Promise(resolve => {\n      if (options.ui) {\n        return Promise.all(map(options.ui, i => i()))\n          .then((args) => zipObject(keys(options.ui), args))\n          .then(resolve)\n      }\n      return resolve(undefined)\n    })\n      .then(payload => {\n        if (payload && typeof payload === 'object') {\n          uiVendors = payload // no reactive shits here\n        }\n        return payload\n      })\n  }\n\n\n  Promise.all([\n    load(),\n    new Promise(resolve => {\n      if (server) return resolve(true)\n      onMounted(() => resolve(true))\n    })\n  ])\n    .then((data) => {\n      nextTick(() => { state.value = STATES.INIT })\n      return data\n    })\n\n  if (motion) {\n    Promise.all([\n      preloadUi(),\n      waitForState(STATES.INIT),\n      new Promise(resolve => onMounted(() => resolve(true)))\n    ]).then((ui) => {\n\n      nextTick(() => {\n        state.value = STATES.INIT_UI\n\n        nextTick(() => {\n          cursorStore.updateCursor();\n          scrollStore.refreshScroll();\n          setTimeout(scrollStore.updateScroll, 500)\n        })\n      })\n      return ui\n    })\n  }\n  // debug('[] autoSetReady?', options.autoSetReady);\n  if (options.autoSetReady) setReady()\n\n  return {\n    loaded: computed(() => state.value >= STATES.LOADED),\n    ready: computed(() => state.value >= STATES.READY),\n    readyToRender: computed(() => state.value >= (motion ? STATES.INIT_UI : STATES.INIT)),\n    getData,\n    getMeta,\n    getSEO,\n    getTranslation,\n    setReady,\n    waitForState,\n    state,\n    /** just after loading stuff - before onInit */\n    onloaded: async function (next: (arg: FlowHookArgs & { data: T }) => unknown) {\n      await waitForState(STATES.INIT)\n      return next({ client, server, motion, data: (unref(_data) as T) })\n    },\n    /** data loaded - like a onMounted() */\n    onInit: async function (next: (arg: FlowHookArgs & { data: T }) => unknown) {\n      await waitForState(STATES.INIT)\n      return next({ client, server, motion, data: (unref(_data) as T) })\n    },\n    onInitUi: async function (next: (arg: FlowHookArgs & { data: T } & { ui: Obj }) => unknown) {\n      if (!motion) return\n      await waitForState(STATES.INIT_UI)\n\n      return next({ client, server, motion, data: (unref(_data) as T), ui: uiVendors })\n    },\n\n  } as FlowPage<T>\n}\n\nexport default usePageFlow\n"],"names":["usePageFlow","opts","options","debug","params","IS_DEV","state","ref","STATES","uiVendors","_a","readonly","_data","_meta","getMeta","_seo","getSEO","_translation","setReady","ready","SEOStore","getTranslation","appStore","scrollStore","requiredState","motion","waitForState","stateToMatch","resolve","unwatch","watch","current"],"mappings":"yPAyHkB,QACA,CAWhB,QAAA,EACE,OAAO,EAGT,KAAA,EAEM,QAAA,EACN,MAAS,CAAA,EACoB,SAAAA,GAAAC,EAAA,GAAA,OA4HvB,MAAAC,EAAA,CAEA,gBAGA,GAAYD,CAAA,EAER,SAAAE,KAAAC,EAAA,CACF,CAAAF,SAAAG,CACA,CACF,MAAAC,EAAAC,EAAAC,EAAA,OAAA,EAKD,IAAAC,EAAY,CAAA,EAEX,YAAkBC,EAAAR,EAAA,OAAA,YAAAQ,EAAA,KAAAR,KAAA,CAAA,CAAA,EAExB,YAAA,CAEA,OAAAS,EAA2BC,CAAA,CAClB,CAKL,MAAAC,EAAAN,EAAA,EAAA,EAGC,SAAAO,GAAgB,CACX,OAAAH,EAAWE,EAAA,KAAA,CACD,CACd,MAAAE,EAAAR,EAAA,EAAA,EAGN,SAAAS,GAAA,CAGA,OAAYL,GAAAI,GAAA,YAAAA,EAAA,QAAA,MAAA,CACV,CACA,MAAAE,EAAAV,EAAA,EAE+B,YAC9B,CACH,OACSI,GAASM,GAAA,YAAAA,EAAA,QAAA,MAAA,CACd,CAAiB,SAAAC,EAAAC,EAAA,GAAA,CAMP,GAAA,CAAAA,EAAA,CACVb,EAAA,MAAAE,EAAA,QACA,MACD,CAEC,GAAAF,EAAA,QAAAE,EAAA,MAAA,CACE,WAAqB,IAAA,CAErBY,EAAS,OAAMJ,EAAA,EAAAK,EAAA,CAAA,EAEbC,EAAA,aAA0B,EAE5BC,EAAC,cAAA,EAEIA,EAAA,UAAA,EACR,WAAA,IAAA,CAGC,OAAA,iBAEG,EAAA,GAAA,CAAA,KACY,QAEjB,CACA,MAAAC,EAAAC,EAAAjB,EAAA,QAAAA,EAAA,KACAL,EAAA,aAAA,CACA,OAAAsB,EACA,MAAAnB,EAAA,MAGA,cAAAkB,CAEA,CAAA,EACQE,eAERN,EAAA,OAAAJ,EAAA,EAAAK,EAAA,CAAA,EAEAf,EAAA,cACQgB,EAAA,aAAwB,EACvBC,EAAA,cAAA,EACT,WAAA,IAAA,CACA,OAAA,eAAA,EAEQ,EAAA,IAEC,CAAA,CACT,CAEF,SAAAG,EAAAC,GACF,OAAA,YAAAC,GAAA,CAEe,MAAAC,EAAAC,EAAAxB,EAAAyB,GAAA"}